<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Translation Manager</title>
    <!-- Import as ES module -->
    <script type="module">
        import OpenAI from 'https://cdn.jsdelivr.net/npm/openai@4.28.0/+esm'
        window.OpenAI = OpenAI;
    </script>
    <link rel="stylesheet" href="styles.css">
    <script type="module">
        // Import franc
        import { franc } from 'https://esm.sh/franc@6?bundle';
        
        // Make franc available globally since our other code needs it
        window.franc = franc;
    </script>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo">
                <img src="https://platform.ibanfirst.com/upload/Cobrands/ibanfirst/favicon.png" alt="Logo" class="logo-img">
                <span class="logo-text">Translation Service</span>
            </div>
            <div class="header-controls">
                <div class="api-input-group">
                    <label for="locoApiKey">Localise API Key:</label>
                    <input type="password" id="locoApiKey" placeholder="Enter your Localise API key">
                    <button id="loadProjectBtn" class="primary-btn">Load Project</button>
                </div>
                <button id="configureBtn" class="configure-btn">
                    <span class="vega-icon-settings"></span>
                    OpenAI API Key
                </button>
            </div>
        </div>
    </div>

    <div id="status" class="status-message"></div>

    <style>
        .status-message {
            margin: 16px auto;
            padding: 12px 24px;
            border-radius: 8px;
            max-width: 1200px;
            display: none;
        }

        .status-message.info {
            background-color: #e3f2fd;
            color: #1976d2;
            display: block;
        }

        .status-message.success {
            background-color: #e8f5e9;
            color: #2e7d32;
            display: block;
        }

        .status-message.error {
            background-color: #ffebee;
            color: #c62828;
            display: block;
        }
    </style>

    <div class="setup-container">
        <div class="setup-grid">
            <div class="setup-column">
                <div>
                    <label>Source Language:</label>
                    <div class="language-grid" id="sourceLangGrid">
                        <!-- Germanic languages -->
                        <button type="button" class="lang-button" data-lang="en-GB" data-selected="true" title="English">
                            <img src="https://flagcdn.com/w20/gb.png" alt="English">
                        </button>
                        <button type="button" class="lang-button" data-lang="de-DE" title="German">
                            <img src="https://flagcdn.com/w20/de.png" alt="German">
                        </button>
                        <button type="button" class="lang-button" data-lang="nl-NL" title="Dutch">
                            <img src="https://flagcdn.com/w20/nl.png" alt="Dutch">
                        </button>

                        <!-- Romance languages -->
                        <button type="button" class="lang-button" data-lang="fr-FR" title="French">
                            <img src="https://flagcdn.com/w20/fr.png" alt="French">
                        </button>
                        <button type="button" class="lang-button" data-lang="es-ES" title="Spanish">
                            <img src="https://flagcdn.com/w20/es.png" alt="Spanish">
                        </button>
                        <button type="button" class="lang-button" data-lang="it-IT" title="Italian">
                            <img src="https://flagcdn.com/w20/it.png" alt="Italian">
                        </button>
                        <button type="button" class="lang-button" data-lang="ro-RO" title="Romanian">
                            <img src="https://flagcdn.com/w20/ro.png" alt="Romanian">
                        </button>

                        <!-- Slavic languages -->
                        <button type="button" class="lang-button" data-lang="cs-CZ" title="Czech">
                            <img src="https://flagcdn.com/w20/cz.png" alt="Czech">
                        </button>
                        <button type="button" class="lang-button" data-lang="bg-BG" title="Bulgarian">
                            <img src="https://flagcdn.com/w20/bg.png" alt="Bulgarian">
                        </button>

                        <!-- Other Indo-European -->
                        <button type="button" class="lang-button" data-lang="el-GR" title="Greek">
                            <img src="https://flagcdn.com/w20/gr.png" alt="Greek">
                        </button>

                        <!-- Uralic languages -->
                        <button type="button" class="lang-button" data-lang="hu-HU" title="Hungarian">
                            <img src="https://flagcdn.com/w20/hu.png" alt="Hungarian">
                        </button>

                        <!-- East Asian languages -->
                        <button type="button" class="lang-button" data-lang="zh-CN" title="Chinese">
                            <img src="https://flagcdn.com/w20/cn.png" alt="Chinese">
                        </button>
                    </div>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="ignoreBlank" checked>
                        Ignore blank source entries
                    </label>
                </div>
            </div>
            <div class="setup-column">
                <div>
                    <label>Target Language:</label>
                    <div class="language-grid" id="targetLangGrid">
                        <!-- Germanic languages -->
                        <button type="button" class="lang-button" data-lang="en-GB" title="English">
                            <img src="https://flagcdn.com/w20/gb.png" alt="English">
                        </button>
                        <button type="button" class="lang-button" data-lang="de-DE" title="German">
                            <img src="https://flagcdn.com/w20/de.png" alt="German">
                        </button>
                        <button type="button" class="lang-button" data-lang="nl-NL" title="Dutch">
                            <img src="https://flagcdn.com/w20/nl.png" alt="Dutch">
                        </button>

                        <!-- Romance languages -->
                        <button type="button" class="lang-button" data-lang="fr-FR" title="French">
                            <img src="https://flagcdn.com/w20/fr.png" alt="French">
                        </button>
                        <button type="button" class="lang-button" data-lang="es-ES" title="Spanish">
                            <img src="https://flagcdn.com/w20/es.png" alt="Spanish">
                        </button>
                        <button type="button" class="lang-button" data-lang="it-IT" title="Italian">
                            <img src="https://flagcdn.com/w20/it.png" alt="Italian">
                        </button>
                        <button type="button" class="lang-button" data-lang="ro-RO" title="Romanian">
                            <img src="https://flagcdn.com/w20/ro.png" alt="Romanian">
                        </button>

                        <!-- Slavic languages -->
                        <button type="button" class="lang-button" data-lang="cs-CZ" title="Czech">
                            <img src="https://flagcdn.com/w20/cz.png" alt="Czech">
                        </button>
                        <button type="button" class="lang-button" data-lang="bg-BG" title="Bulgarian">
                            <img src="https://flagcdn.com/w20/bg.png" alt="Bulgarian">
                        </button>

                        <!-- Other Indo-European -->
                        <button type="button" class="lang-button" data-lang="el-GR" title="Greek">
                            <img src="https://flagcdn.com/w20/gr.png" alt="Greek">
                        </button>

                        <!-- Uralic languages -->
                        <button type="button" class="lang-button" data-lang="hu-HU" title="Hungarian">
                            <img src="https://flagcdn.com/w20/hu.png" alt="Hungarian">
                        </button>

                        <!-- East Asian languages -->
                        <button type="button" class="lang-button" data-lang="zh-CN" title="Chinese">
                            <img src="https://flagcdn.com/w20/cn.png" alt="Chinese">
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    
    <div class="stats-container">
        <div class="stats-grid">
            <div class="stat-item">
                <label>Total Entries:</label>
                <span id="totalEntries">0</span>
            </div>
            <div class="stat-item">
                <label>Translated Entries:</label>
                <span id="translatedEntries">0</span>
            </div>
        </div>
        <div class="progress-container">
            <div class="progress">
                <div class="progress-fill" id="progressFill">
                    <span id="progressPercentage">0%</span>
                </div>
            </div>
        </div>
    </div>

    <div class="control-panel">
        <div class="batch-size-container">
            <label for="batchSize">Batch Size:</label>
            <input type="number" id="batchSize" value="10" min="1" max="50">
        </div>
        <button id="startBtn">Start Translation</button>
        <button id="nextBtn" disabled>Next Batch</button>
        <button id="saveBtn" disabled>Save Translations</button>
    </div>

    <table>
        <thead>
            <tr>
                <th>Asset ID</th>
                <th>English</th>
                <th>Original Translation</th>
                <th>New Translation</th>
            </tr>
        </thead>
        <tbody id="translationTable">
            <!-- Translations will be inserted here -->
        </tbody>
    </table>

    <div id="apiModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>OpenAI API Configuration</h2>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="input-group">
                    <label for="openaiApiKey">OpenAI API Key</label>
                    <input type="password" id="openaiApiKey" placeholder="Enter your OpenAI API key">
                </div>
            </div>
            <div class="modal-footer">
                <button id="saveApiKeys" class="save-btn">Save Configuration</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize all global variables
        let currentData = {
            englishSource: {},
            originalTranslations: {},
            translations: {},
            totalEntries: 0,
            currentBatch: 0,
            batchSize: 10,
            targetLang: '',
            sourceLang: 'en-GB',
            processedKeys: new Set()
        };
        
        let openaiClient = null;

        // Define all necessary functions
        function savePreferences() {
            const preferences = {
                sourceLang: getSelectedLanguage('sourceLangGrid'),
                targetLang: getSelectedLanguage('targetLangGrid'),
                batchSize: document.getElementById('batchSize').value,
                ignoreBlank: document.getElementById('ignoreBlank').checked,
                ignoreTranslated: document.getElementById('ignoreTranslated').checked,
                onlyEmpty: document.getElementById('onlyEmpty').checked,
                locoApiKey: document.getElementById('locoApiKey').value
            };
            localStorage.setItem('translationPreferences', JSON.stringify(preferences));
        }

        function getSelectedLanguage(gridId) {
            const selectedButton = document.querySelector(`#${gridId} .lang-button[data-selected="true"]`);
            console.log('Getting selected language for', gridId, ':', selectedButton?.dataset.lang);
            return selectedButton ? selectedButton.dataset.lang : null;
        }

        function getSelectedLanguageName(gridId) {
            const selectedButton = document.querySelector(`#${gridId} .lang-button[data-selected="true"]`);
            console.log('Getting selected language name for', gridId, ':', selectedButton?.textContent.trim());
            return selectedButton ? selectedButton.textContent.trim() : null;
        }

        function updateTableHeaders() {
            const headerRow = document.querySelector('table thead tr');
            const sourceLangButton = document.querySelector('#sourceLangGrid .lang-button[data-selected="true"]');
            const targetLangButton = document.querySelector('#targetLangGrid .lang-button[data-selected="true"]');
            
            if (sourceLangButton && targetLangButton) {
                const sourceLangName = sourceLangButton.getAttribute('title');
                const targetLangName = targetLangButton.getAttribute('title');
                
                headerRow.innerHTML = `
                    <th>Asset ID</th>
                    <th>${sourceLangName} (Source)</th>
                    <th>${targetLangName} (Original Translation)</th>
                    <th>${targetLangName} (New Translation)</th>
                `;
            }
        }

        function loadSavedPreferences() {
            try {
                const savedPreferences = JSON.parse(localStorage.getItem('translationPreferences')) || {};
                console.log('Loading saved preferences:', { ...savedPreferences, locoApiKey: '***', openaiApiKey: '***' });
                
                // Load API keys
                if (savedPreferences.locoApiKey) {
                    document.getElementById('locoApiKey').value = savedPreferences.locoApiKey;
                }
                if (savedPreferences.openaiApiKey) {
                    document.getElementById('openaiApiKey').value = savedPreferences.openaiApiKey;
                }
                
                // Load language selections
                if (savedPreferences.sourceLang) {
                    const sourceButton = document.querySelector(`#sourceLangGrid .lang-button[data-lang="${savedPreferences.sourceLang}"]`);
                    if (sourceButton) {
                        document.querySelectorAll('#sourceLangGrid .lang-button').forEach(btn => {
                            btn.dataset.selected = 'false';
                        });
                        sourceButton.dataset.selected = 'true';
                    }
                }
                
                if (savedPreferences.targetLang) {
                    const targetButton = document.querySelector(`#targetLangGrid .lang-button[data-lang="${savedPreferences.targetLang}"]`);
                    if (targetButton) {
                        document.querySelectorAll('#targetLangGrid .lang-button').forEach(btn => {
                            btn.dataset.selected = 'false';
                        });
                        targetButton.dataset.selected = 'true';
                    }
                }
                
                // Load other preferences
                document.getElementById('batchSize').value = savedPreferences.batchSize || 10;
                document.getElementById('ignoreBlank').checked = savedPreferences.ignoreBlank !== false;
                
                updateTableHeaders();
            } catch (error) {
                console.error('Error loading preferences:', error);
            }
        }

        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize language buttons
            initLanguageButtons();
            
            // Load saved preferences
            loadSavedPreferences();

            // Add start button handler
            const startBtn = document.getElementById('startBtn');
            startBtn.addEventListener('click', async () => {
                try {
                    const locoApiKey = document.getElementById('locoApiKey').value;
                    const openaiApiKey = localStorage.getItem('openaiApiKey');
                    const targetLang = getSelectedLanguage('targetLangGrid');
                    const sourceLang = getSelectedLanguage('sourceLangGrid');
                    const batchSize = parseInt(document.getElementById('batchSize').value);
                    const ignoreBlank = document.getElementById('ignoreBlank').checked;
                    const ignoreTranslated = document.getElementById('ignoreTranslated').checked;
                    const onlyEmpty = document.getElementById('onlyEmpty').checked;

                    if (!locoApiKey || !openaiApiKey || !targetLang || !sourceLang) {
                        showStatus('Please fill in all required fields and select both languages', 'error');
                        return;
                    }

                    showStatus('Loading project data...', 'info');

                    // Load translations
                    const response = await fetch(`/api/translations?key=${encodeURIComponent(locoApiKey)}`);
                    if (!response.ok) throw new Error(`API error: ${response.status} ${response.statusText}`);
                    
                    const data = await response.json();
                    
                    // Prepare data
                    let sourceData = flattenObject(data[sourceLang] || {});
                    if (ignoreBlank) {
                        sourceData = Object.fromEntries(
                            Object.entries(sourceData).filter(([_, value]) => 
                                value && typeof value === 'string' && value.trim() !== ''
                            )
                        );
                    }

                    // Get original translations
                    const originalTranslations = flattenObject(data[targetLang] || {});

                    // Filter out already translated entries if needed
                    let entriesToTranslate = { ...sourceData };
                    let skippedCount = 0;

                    entriesToTranslate = Object.fromEntries(
                        Object.entries(sourceData).filter(([key, sourceText]) => {
                            const existingTranslation = originalTranslations[key];
                            
                            // Skip if entry has translation and we only want empty entries
                            if (onlyEmpty && existingTranslation && existingTranslation.trim() !== '') {
                                skippedCount++;
                                return false;
                            }
                            
                            // Skip if entry has translation in target language and ignoreTranslated is checked
                            if (ignoreTranslated && existingTranslation) {
                                const shouldTranslate = shouldTranslateEntry(sourceText, existingTranslation, targetLang);
                                if (!shouldTranslate) {
                                    skippedCount++;
                                    return false;
                                }
                            }
                            
                            return true;
                        })
                    );

                    // Initialize OpenAI client
                    openaiClient = new OpenAI({
                        apiKey: openaiApiKey,
                        dangerouslyAllowBrowser: true
                    });

                    // Set up current data
                    currentData = {
                        englishSource: entriesToTranslate,
                        originalTranslations: originalTranslations,
                        translations: {},
                        totalEntries: Object.keys(entriesToTranslate).length,
                        currentBatch: 0,
                        batchSize: batchSize,
                        targetLang: targetLang,
                        sourceLang: sourceLang,
                        processedKeys: new Set()
                    };

                    // Clear and set up table
                    const translationTable = document.getElementById('translationTable');
                    translationTable.innerHTML = '';
                    
                    // Add headers
                    updateTableHeaders();
                    
                    // Load all entries into table with empty new translation column
                    const allEntries = Object.entries(entriesToTranslate);
                    allEntries.forEach(([key, sourceText]) => {
                        const row = translationTable.insertRow();
                        row.id = `row-${key}`;
                        
                        // Key column
                        const keyCell = row.insertCell();
                        keyCell.textContent = key;
                        
                        // Source text column
                        const sourceCell = row.insertCell();
                        sourceCell.textContent = sourceText;
                        
                        // Original translation column
                        const originalCell = row.insertCell();
                        originalCell.textContent = originalTranslations[key] || '';
                        
                        // New translation column (empty for now)
                        const newCell = row.insertCell();
                        newCell.id = `translation-${key}`;
                        newCell.textContent = '';
                    });

                    // Update UI state
                    startBtn.disabled = true;
                    const nextBtn = document.getElementById('nextBtn');
                    const saveBtn = document.getElementById('saveBtn');
                    nextBtn.disabled = currentData.totalEntries === 0;
                    saveBtn.disabled = false;

                    // Update statistics
                    updateStatistics();

                    const skippedMessage = skippedCount > 0 ? 
                        ` (${skippedCount} entries skipped as already translated)` : '';
                    showStatus(`Loaded ${currentData.totalEntries} entries${skippedMessage}. Click "Next Batch" to start translation.`, 'success');

                } catch (error) {
                    console.error('Error:', error);
                    showStatus('Error: ' + error.message, 'error');
                    startBtn.disabled = false;
                }
            });

            // Add change handlers for API key inputs
            document.getElementById('locoApiKey').addEventListener('change', savePreferences);
            document.getElementById('openaiApiKey').addEventListener('change', savePreferences);
            document.getElementById('batchSize').addEventListener('change', savePreferences);
            document.getElementById('ignoreBlank').addEventListener('change', savePreferences);

            // Add Next button handler
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.addEventListener('click', () => {
                processBatch();
            });

            // Add Save button handler
            const saveBtn = document.getElementById('saveBtn');
            saveBtn.addEventListener('click', async () => {
                try {
                    showStatus('Preparing translations for download...', 'info');
                    
                    // Create an object with translations and unflatten it
                    const exportData = {
                        [currentData.targetLang]: unflattenObject(currentData.translations)
                    };

                    // Create a Blob with the JSON data
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    
                    // Create a download link
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(blob);
                    downloadLink.download = `translations_${currentData.targetLang}_${new Date().toISOString().split('T')[0]}.json`;
                    
                    // Trigger the download
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    
                    showStatus('Translations downloaded successfully!', 'success');

                } catch (error) {
                    console.error('Error preparing download:', error);
                    showStatus('Error preparing download: ' + error.message, 'error');
                }
            });

            const modal = document.getElementById('apiModal');
            const configureBtn = document.getElementById('configureBtn');
            const closeBtn = document.querySelector('.close-modal');
            const saveApiKeysBtn = document.getElementById('saveApiKeys');

            // Add this function to handle API key display
            function formatApiKeyDisplay(apiKey) {
                if (!apiKey) return '';
                if (apiKey.length < 7) return apiKey; // If key is too short, show as is
                return `${apiKey.slice(0, 3)}...${apiKey.slice(-4)}`;
            }

            // Update the modal open handler to show masked key
            configureBtn.addEventListener('click', () => {
                modal.style.display = 'block';
                // Load saved OpenAI key if exists
                const openaiKey = localStorage.getItem('openaiApiKey');
                const openaiInput = document.getElementById('openaiApiKey');
                
                if (openaiKey) {
                    openaiInput.value = openaiKey;
                    openaiInput.setAttribute('data-full-key', openaiKey);
                    openaiInput.value = formatApiKeyDisplay(openaiKey);
                }
            });

            // Add input handler to manage key display/edit
            document.getElementById('openaiApiKey').addEventListener('focus', function() {
                const fullKey = this.getAttribute('data-full-key');
                if (fullKey) {
                    this.value = fullKey;
                }
            });

            document.getElementById('openaiApiKey').addEventListener('blur', function() {
                if (this.value.length > 0) {
                    this.setAttribute('data-full-key', this.value);
                    this.value = formatApiKeyDisplay(this.value);
                }
            });

            // Update save handler to use full key
            saveApiKeysBtn.addEventListener('click', () => {
                const openaiInput = document.getElementById('openaiApiKey');
                const openaiKey = openaiInput.getAttribute('data-full-key') || openaiInput.value;
                
                localStorage.setItem('openaiApiKey', openaiKey);
                modal.style.display = 'none';
                
                // Reinitialize OpenAI client with new key
                openaiClient = new OpenAI({
                    apiKey: openaiKey,
                    dangerouslyAllowBrowser: true
                });
                
                showStatus('OpenAI API key saved successfully', 'success');
            });

            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });

            window.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });

            const loadProjectBtn = document.getElementById('loadProjectBtn');
            loadProjectBtn.addEventListener('click', async () => {
                try {
                    const locoApiKey = document.getElementById('locoApiKey').value;

                    if (!locoApiKey) {
                        showStatus('Please enter your Localise API key', 'error');
                        return;
                    }

                    // Show loading status
                    showStatus('Loading project data...', 'info');

                    // Use GET request with query parameter as defined in server.js
                    const response = await fetch(`/api/translations?key=${encodeURIComponent(locoApiKey)}`);

                    if (!response.ok) {
                        throw new Error(`API error: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log('Received data:', data);

                    // Update statistics
                    const totalEntries = Object.keys(data['en-GB'] || {}).length;
                    document.getElementById('totalEntries').textContent = totalEntries;
                    document.getElementById('translatedEntries').textContent = '0';
                    document.getElementById('progressPercentage').textContent = '0%';
                    document.getElementById('progressFill').style.width = '0%';

                    // Store the data for later use
                    window.translationData = data;

                    showStatus('Project loaded successfully!', 'success');

                } catch (error) {
                    console.error('Error:', error);
                    showStatus('Error loading project: ' + error.message, 'error');
                }
            });
        });

        function initLanguageButtons() {
            // Source language buttons
            document.querySelectorAll('#sourceLangGrid .lang-button').forEach(button => {
                button.addEventListener('click', () => {
                    console.log('Source button clicked:', button.textContent);
                    
                    document.querySelectorAll('#sourceLangGrid .lang-button').forEach(btn => {
                        btn.dataset.selected = 'false';
                    });
                    
                    button.dataset.selected = 'true';
                    currentData.sourceLang = button.dataset.lang;
                    
                    savePreferences();
                    updateTableHeaders();
                });
            });

            // Target language buttons
            document.querySelectorAll('#targetLangGrid .lang-button').forEach(button => {
                button.addEventListener('click', () => {
                    console.log('Target button clicked:', button.textContent);
                    
                    document.querySelectorAll('#targetLangGrid .lang-button').forEach(btn => {
                        btn.dataset.selected = 'false';
                    });
                    
                    button.dataset.selected = 'true';
                    currentData.targetLang = button.dataset.lang;
                    
                    savePreferences();
                    updateTableHeaders();
                });
            });
        }

        // Add status display function
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            if (!statusDiv) {
                console.error('Status element not found');
                return;
            }
            
            statusDiv.textContent = message;
            statusDiv.className = 'status-message ' + type;
            
            // Optionally auto-hide success messages after 3 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

        // Add translateText function
        async function translateText(text, targetLang) {
            try {
                const completion = await openaiClient.chat.completions.create({
                    messages: [
                        {
                            role: "system",
                            content: `You are a translator for an FX web platform. Translate to ${targetLang}, keeping HTML tags, placeholders, and special characters intact. Respond with only the translation.`
                        },
                        {
                            role: "user",
                            content: text
                        }
                    ],
                    model: "gpt-3.5-turbo",
                });

                return completion.choices[0].message.content.trim();
            } catch (error) {
                console.error('Translation error:', error);
                throw new Error(`Translation failed: ${error.message}`);
            }
        }

        // Add this to your global variables
        const SUPPORTED_LANGUAGES = {
            'en-GB': 'eng',  // English
            'de-DE': 'deu',  // German
            'nl-NL': 'nld',  // Dutch
            'fr-FR': 'fra',  // French
            'es-ES': 'spa',  // Spanish
            'it-IT': 'ita',  // Italian
            'ro-RO': 'ron',  // Romanian
            'cs-CZ': 'ces',  // Czech
            'bg-BG': 'bul',  // Bulgarian
            'el-GR': 'ell',  // Greek
            'hu-HU': 'hun',  // Hungarian
            'zh-CN': 'cmn'   // Chinese
        };

        // Add language detection function
        function detectLanguage(text) {
            // Wait for franc to be available
            if (typeof window.franc === 'undefined') {
                console.error('Franc not loaded yet');
                return null;
            }
            
            if (!text || text.trim().length < 10) return null;
            
            try {
                const detectedLang = window.franc(text, {
                    only: Object.values(SUPPORTED_LANGUAGES),
                    minLength: 1
                });
                console.log('Detected language:', detectedLang);
                
                return Object.keys(SUPPORTED_LANGUAGES).find(
                    locale => SUPPORTED_LANGUAGES[locale] === detectedLang
                );
            } catch (error) {
                console.error('Language detection error:', error);
                return null;
            }
        }

        // Add checkbox to HTML right after target language selection
        const targetLangSection = document.querySelector('#targetLangGrid').parentElement;
        const ignoreTranslatedCheckbox = document.createElement('div');
        ignoreTranslatedCheckbox.className = 'checkbox-group';
        ignoreTranslatedCheckbox.innerHTML = `
            <label>
                <input type="checkbox" id="ignoreTranslated" checked>
                Ignore entries already translated in target language
            </label>
        `;
        targetLangSection.appendChild(ignoreTranslatedCheckbox);

        // Add the new checkbox right after
        const onlyEmptyCheckbox = document.createElement('div');
        onlyEmptyCheckbox.className = 'checkbox-group';
        onlyEmptyCheckbox.innerHTML = `
            <label>
                <input type="checkbox" id="onlyEmpty" checked>
                Only translate empty entries
            </label>
        `;
        targetLangSection.appendChild(onlyEmptyCheckbox);

        // Update the translation process to skip already translated entries
        function shouldTranslateEntry(sourceText, existingTranslation, targetLang) {
            // If no existing translation, always translate
            if (!existingTranslation) return true;
            
            // Detect language of existing translation
            const detectedLang = detectLanguage(existingTranslation);
            
            // If we can't detect the language (too short/ambiguous) or 
            // if detected language doesn't match target language, translate it
            if (!detectedLang || detectedLang !== targetLang) return true;
            
            // If ignore translated is checked and text is in target language, skip it
            return !document.getElementById('ignoreTranslated').checked;
        }

        // Update processBatch to only handle translations
        async function processBatch() {
            try {
                const entries = Object.entries(currentData.englishSource)
                    .filter(([key]) => !currentData.processedKeys.has(key))
                    .slice(0, currentData.batchSize);

                for (const [key, sourceText] of entries) {
                    const existingTranslation = currentData.originalTranslations[key];
                    
                    if (shouldTranslateEntry(sourceText, existingTranslation, currentData.targetLang)) {
                        showStatus(`Translating entry ${currentData.processedKeys.size + 1}/${currentData.totalEntries}...`, 'info');
                        const translation = await translateText(sourceText, currentData.targetLang);
                        currentData.translations[key] = translation;
                        
                        // Update only the new translation cell
                        const cell = document.getElementById(`translation-${key}`);
                        if (cell) cell.textContent = translation;
                    } else {
                        currentData.translations[key] = existingTranslation;
                        const cell = document.getElementById(`translation-${key}`);
                        if (cell) cell.textContent = existingTranslation;
                        console.log(`Skipping translation for ${key} - already in target language`);
                    }
                    
                    currentData.processedKeys.add(key);
                }
                
                // Update statistics and UI
                updateStatistics();
                
                const saveBtn = document.getElementById('saveBtn');
                saveBtn.disabled = false;
                
                const nextBtn = document.getElementById('nextBtn');
                nextBtn.disabled = currentData.processedKeys.size >= currentData.totalEntries;
                
                if (currentData.processedKeys.size >= currentData.totalEntries) {
                    showStatus('All translations completed!', 'success');
                }
            } catch (error) {
                console.error('Batch processing error:', error);
                showStatus('Error processing batch: ' + error.message, 'error');
            }
        }

        // Add statistics update function
        function updateStatistics() {
            const totalEntries = Object.keys(currentData.englishSource || {}).length;
            const translatedEntries = currentData.processedKeys.size;
            const progressPercentage = totalEntries ? Math.round((translatedEntries / totalEntries) * 100) : 0;

            document.getElementById('totalEntries').textContent = totalEntries;
            document.getElementById('translatedEntries').textContent = translatedEntries;
            document.getElementById('progressPercentage').textContent = `${progressPercentage}%`;
            document.getElementById('progressFill').style.width = `${progressPercentage}%`;
        }

        // Add helper function to flatten nested objects
        function flattenObject(obj, prefix = '') {
            return Object.keys(obj).reduce((acc, key) => {
                const pre = prefix.length ? prefix + '.' : '';
                if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
                    Object.assign(acc, flattenObject(obj[key], pre + key));
                } else {
                    acc[pre + key] = obj[key];
                }
                return acc;
            }, {});
        }

        // Add helper function to unflatten object for export
        function unflattenObject(obj) {
            const result = {};
            
            for (const key in obj) {
                const keys = key.split('.');
                let current = result;
                
                for (let i = 0; i < keys.length - 1; i++) {
                    current[keys[i]] = current[keys[i]] || {};
                    current = current[keys[i]];
                }
                
                current[keys[keys.length - 1]] = obj[key];
            }
            
            return result;
        }
    </script>
</body>
</html> 