<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Translation Manager</title>
    <!-- Import as ES module -->
    <script type="module">
        import OpenAI from 'https://cdn.jsdelivr.net/npm/openai@4.28.0/+esm'
        window.OpenAI = OpenAI;
    </script>
    <link rel="stylesheet" href="styles.css">
    <script type="module">
        // Import franc
        import { franc } from 'https://esm.sh/franc@6?bundle';
        
        // Make franc available globally since our other code needs it
        window.franc = franc;
    </script>
    <script>
        // Fetch the glossary file
        fetch('./glossary.json')
            .then(response => response.json())
            .then(data => {
                window.glossary = data;
                console.log('Glossary loaded:', window.glossary);
            })
            .catch(error => console.error('Error loading glossary:', error));
    </script>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo">
                <img src="https://platform.ibanfirst.com/upload/Cobrands/ibanfirst/favicon.png" alt="Logo" class="logo-img">
                <span class="logo-text">Translation Service</span>
            </div>
            <div class="header-controls">
                <div class="api-input-group">
                    <label for="locoApiKey">Localise API Key:</label>
                    <input type="password" id="locoApiKey" placeholder="Enter your Localise API key">
                    <button id="loadProjectBtn" class="primary-btn">Load Project</button>
                </div>
                <button id="configureBtn" class="configure-btn">
                    <span class="vega-icon-settings"></span>
                    OpenAI API Key
                </button>
            </div>
        </div>
    </div>

    <div id="status" class="status-message"></div>

    <style>
        .status-message {
            margin: 16px auto;
            padding: 12px 24px;
            border-radius: 8px;
            max-width: 1200px;
            display: none;
        }

        .status-message.info {
            background-color: #e3f2fd;
            color: #1976d2;
            display: block;
        }

        .status-message.success {
            background-color: #e8f5e9;
            color: #2e7d32;
            display: block;
        }

        .status-message.error {
            background-color: #ffebee;
            color: #c62828;
            display: block;
        }
    </style>

    <div class="setup-container">
        <div class="setup-grid">
            <div class="setup-column">
                <div>
                    <label>Source Language:</label>
                    <div class="language-grid" id="sourceLangGrid">
                        <!-- Germanic languages -->
                        <button type="button" class="lang-button" data-lang="en-GB" data-selected="true" title="English">
                            <img src="https://flagcdn.com/w20/gb.png" alt="English">
                        </button>
                        <button type="button" class="lang-button" data-lang="de-DE" title="German">
                            <img src="https://flagcdn.com/w20/de.png" alt="German">
                        </button>
                        <button type="button" class="lang-button" data-lang="nl-NL" title="Dutch">
                            <img src="https://flagcdn.com/w20/nl.png" alt="Dutch">
                        </button>

                        <!-- Romance languages -->
                        <button type="button" class="lang-button" data-lang="fr-FR" title="French">
                            <img src="https://flagcdn.com/w20/fr.png" alt="French">
                        </button>
                        <button type="button" class="lang-button" data-lang="es-ES" title="Spanish">
                            <img src="https://flagcdn.com/w20/es.png" alt="Spanish">
                        </button>
                        <button type="button" class="lang-button" data-lang="it-IT" title="Italian">
                            <img src="https://flagcdn.com/w20/it.png" alt="Italian">
                        </button>
                        <button type="button" class="lang-button" data-lang="ro-RO" title="Romanian">
                            <img src="https://flagcdn.com/w20/ro.png" alt="Romanian">
                        </button>

                        <!-- Slavic languages -->
                        <button type="button" class="lang-button" data-lang="cs-CZ" title="Czech">
                            <img src="https://flagcdn.com/w20/cz.png" alt="Czech">
                        </button>
                        <button type="button" class="lang-button" data-lang="bg-BG" title="Bulgarian">
                            <img src="https://flagcdn.com/w20/bg.png" alt="Bulgarian">
                        </button>

                        <!-- Other Indo-European -->
                        <button type="button" class="lang-button" data-lang="el-GR" title="Greek">
                            <img src="https://flagcdn.com/w20/gr.png" alt="Greek">
                        </button>

                        <!-- Uralic languages -->
                        <button type="button" class="lang-button" data-lang="hu-HU" title="Hungarian">
                            <img src="https://flagcdn.com/w20/hu.png" alt="Hungarian">
                        </button>

                        <!-- East Asian languages -->
                        <button type="button" class="lang-button" data-lang="zh-CN" title="Chinese">
                            <img src="https://flagcdn.com/w20/cn.png" alt="Chinese">
                        </button>
                    </div>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="ignoreBlank" checked>
                        Ignore blank source entries
                    </label>
                </div>
            </div>
            <div class="setup-column">
                <div>
                    <label>Target Language:</label>
                    <div class="language-grid" id="targetLangGrid">
                        <!-- Germanic languages -->
                        <button type="button" class="lang-button" data-lang="en-GB" title="English">
                            <img src="https://flagcdn.com/w20/gb.png" alt="English">
                        </button>
                        <button type="button" class="lang-button" data-lang="de-DE" title="German">
                            <img src="https://flagcdn.com/w20/de.png" alt="German">
                        </button>
                        <button type="button" class="lang-button" data-lang="nl-NL" title="Dutch">
                            <img src="https://flagcdn.com/w20/nl.png" alt="Dutch">
                        </button>

                        <!-- Romance languages -->
                        <button type="button" class="lang-button" data-lang="fr-FR" title="French">
                            <img src="https://flagcdn.com/w20/fr.png" alt="French">
                        </button>
                        <button type="button" class="lang-button" data-lang="es-ES" title="Spanish">
                            <img src="https://flagcdn.com/w20/es.png" alt="Spanish">
                        </button>
                        <button type="button" class="lang-button" data-lang="it-IT" title="Italian">
                            <img src="https://flagcdn.com/w20/it.png" alt="Italian">
                        </button>
                        <button type="button" class="lang-button" data-lang="ro-RO" title="Romanian">
                            <img src="https://flagcdn.com/w20/ro.png" alt="Romanian">
                        </button>

                        <!-- Slavic languages -->
                        <button type="button" class="lang-button" data-lang="cs-CZ" title="Czech">
                            <img src="https://flagcdn.com/w20/cz.png" alt="Czech">
                        </button>
                        <button type="button" class="lang-button" data-lang="bg-BG" title="Bulgarian">
                            <img src="https://flagcdn.com/w20/bg.png" alt="Bulgarian">
                        </button>

                        <!-- Other Indo-European -->
                        <button type="button" class="lang-button" data-lang="el-GR" title="Greek">
                            <img src="https://flagcdn.com/w20/gr.png" alt="Greek">
                        </button>

                        <!-- Uralic languages -->
                        <button type="button" class="lang-button" data-lang="hu-HU" title="Hungarian">
                            <img src="https://flagcdn.com/w20/hu.png" alt="Hungarian">
                        </button>

                        <!-- East Asian languages -->
                        <button type="button" class="lang-button" data-lang="zh-CN" title="Chinese">
                            <img src="https://flagcdn.com/w20/cn.png" alt="Chinese">
                        </button>
                    </div>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="ignoreTranslated">
                        Ignore entries already translated in target language
                    </label>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="onlyEmpty">
                        Only translate empty entries
                    </label>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="translateAll">
                        Translate to all target languages at once
                    </label>
                </div>
                <div class="filter-group">
                    <input type="checkbox" id="filterCheckbox">
                    <label for="filterCheckbox">Ignore entries with tag "sameassource"</label>
                </div>
            </div>
        </div>
    </div>

    
    <div class="stats-container">
        <div class="stats-grid">
            <div class="stat-item">
                <label>Total Entries:</label>
                <span id="totalEntries">0</span>
            </div>
            <div class="stat-item">
                <label>Translated Entries:</label>
                <span id="translatedEntries">0</span>
            </div>
        </div>
        <div class="progress-container">
            <div class="progress">
                <div class="progress-fill" id="progressFill">
                    <span id="progressPercentage">0%</span>
                </div>
            </div>
        </div>
    </div>

    <div class="control-panel">
        <div class="batch-size-container">
            <label for="batchSize">Batch Size:</label>
            <input type="number" id="batchSize" value="10" min="1" max="50">
        </div>
        <button id="startBtn">Start Translation</button>
        <button id="nextBtn" disabled>Next Batch</button>
        <button id="saveBtn" disabled>Save Translations</button>
    </div>

    <table>
        <thead>
            <tr>
                <th colspan="4" class="language-navigation">
                    <div class="language-nav-container">
                        <button class="lang-nav-btn" id="prevLang">←</button>
                        <span id="currentTargetLang"></span>
                        <button class="lang-nav-btn" id="nextLang">→</button>
                    </div>
                </th>
            </tr>
            <tr>
                <th>Asset ID</th>
                <th id="sourceHeader">English (Source)</th>
                <th id="targetHeader1">Original Translation</th>
                <th id="targetHeader2">New Translation</th>
            </tr>
        </thead>
        <tbody id="translationTable">
            <!-- Translations will be inserted here -->
        </tbody>
    </table>

    <div id="apiModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>OpenAI API Configuration</h2>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="input-group">
                    <label for="openaiApiKey">OpenAI API Key</label>
                    <input type="password" id="openaiApiKey" placeholder="Enter your OpenAI API key">
                </div>
            </div>
            <div class="modal-footer">
                <button id="saveApiKeys" class="save-btn">Save Configuration</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize all global variables
        let currentData = {
            englishSource: {},
            originalTranslations: {},
            translations: {},
            totalEntries: 0,
            currentBatch: 0,
            batchSize: 10,
            targetLang: '',
            sourceLang: 'en-GB',
            processedKeys: new Set(),
            multiLanguageTranslations: {},
            processedLanguages: new Set(),
            currentBatchProgress: 0,
            translationQueue: [], // Store entries that need translation
            translationResults: {} // Store completed translations for all languages
        };
        
        let openaiClient = null;

        // Add this flag at the top with other global variables
        let isSaving = false;

        // Define all necessary functions
        function savePreferences() {
            const preferences = {
                sourceLang: getSelectedLanguage('sourceLangGrid'),
                targetLang: getSelectedLanguage('targetLangGrid'),
                batchSize: document.getElementById('batchSize').value,
                ignoreBlank: document.getElementById('ignoreBlank').checked,
                ignoreTranslated: document.getElementById('ignoreTranslated').checked,
                onlyEmpty: document.getElementById('onlyEmpty').checked,
                locoApiKey: document.getElementById('locoApiKey').value,
                filterCheckbox: document.getElementById('filterCheckbox').checked,
            };
            localStorage.setItem('translationPreferences', JSON.stringify(preferences));
        }

        function getSelectedLanguage(gridId) {
            const selectedButton = document.querySelector(`#${gridId} .lang-button[data-selected="true"]`);
            console.log('Getting selected language for', gridId, ':', selectedButton?.dataset.lang);
            return selectedButton ? selectedButton.dataset.lang : null;
        }

        function getSelectedLanguageName(gridId) {
            const selectedButton = document.querySelector(`#${gridId} .lang-button[data-selected="true"]`);
            console.log('Getting selected language name for', gridId, ':', selectedButton?.textContent.trim());
            return selectedButton ? selectedButton.textContent.trim() : null;
        }

        function updateTableHeaders() {
            const sourceLangButton = document.querySelector('#sourceLangGrid .lang-button[data-selected="true"]');
            const targetLangButton = document.querySelector('#targetLangGrid .lang-button[data-selected="true"]');
            
            if (sourceLangButton && targetLangButton) {
                const sourceLangName = sourceLangButton.getAttribute('title');
                const targetLangName = targetLangButton.getAttribute('title');
                
                document.getElementById('sourceHeader').textContent = `${sourceLangName} (Source)`;
                document.getElementById('targetHeader1').textContent = `${targetLangName} (Original Translation)`;
                document.getElementById('targetHeader2').textContent = `${targetLangName} (New Translation)`;
            }
        }

        function loadSavedPreferences() {
            try {
                const savedPreferences = JSON.parse(localStorage.getItem('translationPreferences')) || {};
                console.log('Loading saved preferences:', { ...savedPreferences, locoApiKey: '***', openaiApiKey: '***' });
                
                // Load API keys
                if (savedPreferences.locoApiKey) {
                    document.getElementById('locoApiKey').value = savedPreferences.locoApiKey;
                }
                if (savedPreferences.openaiApiKey) {
                    document.getElementById('openaiApiKey').value = savedPreferences.openaiApiKey;
                }
                
                // Load language selections
                if (savedPreferences.sourceLang) {
                    const sourceButton = document.querySelector(`#sourceLangGrid .lang-button[data-lang="${savedPreferences.sourceLang}"]`);
                    if (sourceButton) {
                        document.querySelectorAll('#sourceLangGrid .lang-button').forEach(btn => {
                            btn.dataset.selected = 'false';
                        });
                        sourceButton.dataset.selected = 'true';
                    }
                }
                
                if (savedPreferences.targetLang) {
                    const targetButton = document.querySelector(`#targetLangGrid .lang-button[data-lang="${savedPreferences.targetLang}"]`);
                    if (targetButton) {
                        document.querySelectorAll('#targetLangGrid .lang-button').forEach(btn => {
                            btn.dataset.selected = 'false';
                        });
                        targetButton.dataset.selected = 'true';
                    }
                }
                
                // Load other preferences
                document.getElementById('batchSize').value = savedPreferences.batchSize || 10;
                document.getElementById('ignoreBlank').checked = savedPreferences.ignoreBlank !== false;
                
                updateTableHeaders();
                document.getElementById('filterCheckbox').checked = savedPreferences.filterCheckbox || false;
            } catch (error) {
                console.error('Error loading preferences:', error);
            }
        }

        // Define all necessary functions
        const supportedLanguages = [
            'en-GB', 'de-DE', 'nl-NL', 'fr-FR', 'es-ES', 
            'it-IT', 'ro-RO', 'cs-CZ', 'bg-BG', 'el-GR', 
            'hu-HU', 'zh-CN'
        ];

        function getNextLanguage(currentLang) {
            const currentIndex = supportedLanguages.indexOf(currentLang);
            return supportedLanguages[(currentIndex + 1) % supportedLanguages.length];
        }

        function getPreviousLanguage(currentLang) {
            const currentIndex = supportedLanguages.indexOf(currentLang);
            return supportedLanguages[(currentIndex - 1 + supportedLanguages.length) % supportedLanguages.length];
        }

        function debugTranslationData(newLang) {
            console.log('=== Translation Debug Info ===');
            console.log('Target Language:', newLang);
            console.log('Window Translation Data:', window.translationData);
            console.log('Current Language Data:', window.translationData?.[newLang]);
            
            // Try to access a known key
            const testKey = 'Settings_Authentication_Title';
            console.log('Test key original translation:', window.translationData?.[newLang]?.[testKey]);
            
            // Log the full data structure
            console.log('Full data structure:', {
                windowTranslationData: window.translationData,
                currentLanguageData: window.translationData?.[newLang],
                currentDataState: currentData,
                flattenedTranslations: window.translationData?.[newLang] ? 
                    flattenObject(window.translationData[newLang]) : 'No data to flatten'
            });
        }

        function updateTargetLanguage(newLang) {
            console.log('Updating target language to:', newLang);
            
            // Simulate clicking "Start Translation" with the new language
            const startTranslationProcess = async () => {
                try {
                    const locoApiKey = document.getElementById('locoApiKey').value;
                    const filterCheckbox = document.getElementById('filterCheckbox').checked;
                    
                    if (!locoApiKey) {
                        showStatus('Please enter your Localise API key', 'error');
                        return;
                    }
                    
                    showStatus('Loading project data...', 'info');
                    
                    // Use existing window.translationData if available instead of fetching again
                    if (!window.translationData) {
                        let url = `/api/translations?key=${locoApiKey}`;
                        if (filterCheckbox) {
                            url += '&filter=!sameassource';
                        }
                        
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`API error: ${response.status} ${response.statusText}`);
                        }
                        
                        window.translationData = await response.json();
                    }
                    
                    // Update UI for new target language
                    document.querySelectorAll('#targetLangGrid .lang-button').forEach(btn => {
                        btn.dataset.selected = btn.dataset.lang === newLang ? 'true' : 'false';
                    });
                    
                    // Update language display text
                    const selectedButton = document.querySelector(`#targetLangGrid .lang-button[data-lang="${newLang}"]`);
                    if (selectedButton) {
                        const targetLangName = selectedButton.getAttribute('title');
                        document.getElementById('currentTargetLang').textContent = targetLangName;
                        
                        // Update table headers
                        document.getElementById('targetHeader1').textContent = `${targetLangName} (Original Translation)`;
                        document.getElementById('targetHeader2').textContent = `${targetLangName} (New Translation)`;
                    }
                    
                    // Get source and target data
                    const sourceLang = getSelectedLanguage('sourceLangGrid');
                    const sourceData = flattenObject(window.translationData[sourceLang] || {});
                    const targetData = flattenObject(window.translationData[newLang] || {});
                    
                    // Get checkbox states
                    const ignoreTranslated = document.getElementById('ignoreTranslated').checked;
                    const onlyEmpty = document.getElementById('onlyEmpty').checked;
                    
                    // Filter entries based on checkbox states
                    let entriesToTranslate = {};
                    let skippedCount = 0;
                    
                    Object.entries(sourceData).forEach(([key, sourceText]) => {
                        const existingTranslation = targetData[key];
                        const isEmpty = !existingTranslation || existingTranslation.trim() === '';
                        
                        let shouldTranslate = true;
                        
                        if (onlyEmpty) {
                            shouldTranslate = isEmpty;
                        } else if (ignoreTranslated) {
                            shouldTranslate = !existingTranslation;
                        }
                        
                        if (shouldTranslate) {
                            entriesToTranslate[key] = sourceText;
                        } else {
                            skippedCount++;
                        }
                    });
                    
                    // Reset currentData for new language
                    currentData = {
                        englishSource: sourceData,
                        targetLang: newLang,
                        translationQueue: Object.entries(entriesToTranslate),
                        totalEntries: Object.keys(entriesToTranslate).length,
                        processedKeys: new Set(),
                        translationResults: currentData.translationResults || {},
                        currentBatch: 0,
                        batchSize: parseInt(document.getElementById('batchSize').value)
                    };
                    
                    // Update UI
                    document.getElementById('totalEntries').textContent = currentData.totalEntries;
                    document.getElementById('translatedEntries').textContent = '0';
                    
                    // Reset progress bar
                    const progressFill = document.getElementById('progressFill');
                    const progressPercentage = document.getElementById('progressPercentage');
                    progressFill.style.width = '0%';
                    progressPercentage.textContent = '0%';
                    
                    // Update table content
                    const translationTable = document.getElementById('translationTable');
                    const rows = Array.from(translationTable.getElementsByTagName('tr'));
                    
                    rows.forEach(row => {
                        if (!row.id) return; // Skip header row
                        const key = row.id.replace('row-', '');
                        
                        // Update original translation column
                        const originalCell = row.cells[2];
                        if (originalCell) {
                            originalCell.textContent = targetData[key] || '';
                        }
                        
                        // Clear new translation column
                        const newTranslationCell = document.getElementById(`translation-${key}`);
                        if (newTranslationCell) {
                            newTranslationCell.textContent = '';
                        }
                        
                        // Update row styling
                        const hasTranslation = !!targetData[key];
                        const isEmpty = !hasTranslation;
                        
                        if ((hasTranslation && ignoreTranslated) || (!isEmpty && onlyEmpty)) {
                            row.style.backgroundColor = '#f5f5f5';
                            row.style.color = '#999';
                        } else {
                            row.style.backgroundColor = '';
                            row.style.color = '';
                        }
                    });
                    
                    // Update Next Batch button state
                    const nextBtn = document.getElementById('nextBtn');
                    nextBtn.disabled = currentData.totalEntries === 0;
                    
                    // Show status message
                    const skippedMessage = skippedCount > 0 ? 
                        ` (${skippedCount} entries skipped as already translated)` : '';
                    showStatus(`Loaded ${currentData.totalEntries} entries${skippedMessage}. Click "Next Batch" to start translation.`, 'success');
                    
                } catch (error) {
                    console.error('Error:', error);
                    showStatus('Error updating target language: ' + error.message, 'error');
                }
            };
            
            // Execute the process
            startTranslationProcess();
        }

        // Helper function to update progress bar
        function updateProgressBar(percentage) {
            const progressFill = document.getElementById('progressFill');
            const progressPercentage = document.getElementById('progressPercentage');
            if (progressFill && progressPercentage) {
                progressFill.style.width = `${percentage}%`;
                progressPercentage.textContent = `${Math.round(percentage)}%`;
            }
        }

        // Helper function to update statistics
        function updateStatistics(needsTranslation, total) {
            const statsDisplay = document.getElementById('statsDisplay');
            if (statsDisplay) {
                statsDisplay.textContent = `Entries to translate: ${needsTranslation} / Total entries: ${total}`;
            }
        }

        function setupNavigationButtons() {
            console.log('Setting up navigation buttons...');
            
            const prevBtn = document.getElementById('prevLang');
            const nextBtn = document.getElementById('nextLang');
            
            if (!prevBtn || !nextBtn) {
                console.error('Navigation buttons not found in DOM');
                return;
            }
            
            console.log('Found navigation buttons:', { prevBtn, nextBtn });

            prevBtn.onclick = () => {
                console.log('Previous button clicked');
                const currentLang = getSelectedLanguage('targetLangGrid');
                console.log('Current language:', currentLang);
                const prevLang = getPreviousLanguage(currentLang);
                console.log('Switching to previous language:', prevLang);
                updateTargetLanguage(prevLang);
            };
            
            nextBtn.onclick = () => {
                console.log('Next button clicked');
                const currentLang = getSelectedLanguage('targetLangGrid');
                console.log('Current language:', currentLang);
                const nextLang = getNextLanguage(currentLang);
                console.log('Switching to next language:', nextLang);
                updateTargetLanguage(nextLang);
            };
        }

        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize language buttons
            initLanguageButtons();
            
            // Load saved preferences
            loadSavedPreferences();
            
            // Setup navigation buttons
            setupNavigationButtons();
            
            // Update initial language display
            const initialLang = getSelectedLanguage('targetLangGrid');
            const initialLangButton = document.querySelector(`#targetLangGrid .lang-button[data-lang="${initialLang}"]`);
            if (initialLangButton) {
                document.getElementById('currentTargetLang').textContent = initialLangButton.getAttribute('title');
            }

            // Add start button handler
            const startBtn = document.getElementById('startBtn');
            startBtn.addEventListener('click', async () => {
                try {
                    // Always use the current value from the input field
                    const locoApiKey = document.getElementById('locoApiKey').value.trim();
                    const openaiApiKey = localStorage.getItem('openaiApiKey');
                    const targetLang = getSelectedLanguage('targetLangGrid');
                    const sourceLang = getSelectedLanguage('sourceLangGrid');
                    const batchSize = parseInt(document.getElementById('batchSize').value);
                    const ignoreBlank = document.getElementById('ignoreBlank').checked;
                    const ignoreTranslated = document.getElementById('ignoreTranslated').checked;
                    const onlyEmpty = document.getElementById('onlyEmpty').checked;
                    const filterCheckbox = document.getElementById('filterCheckbox').checked;

                    if (!locoApiKey || !openaiApiKey || !targetLang || !sourceLang) {
                        showStatus('Please fill in all required fields and select both languages', 'error');
                        return;
                    }

                    showStatus('Loading project data...', 'info');

                    // Load translations with filter if checkbox is checked
                    let url = `/api/translations?key=${locoApiKey}`;
                    if (filterCheckbox) {
                        url += '&filter=!sameassource';
                    }

                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`API error: ${response.status} ${response.statusText}`);
                    
                    const data = await response.json();
                    
                    // Prepare data
                    let sourceData = flattenObject(data[sourceLang] || {});
                    if (ignoreBlank) {
                        sourceData = Object.fromEntries(
                            Object.entries(sourceData).filter(([_, value]) => 
                                value && typeof value === 'string' && value.trim() !== ''
                            )
                        );
                    }

                    // Get original translations
                    const originalTranslations = flattenObject(data[targetLang] || {});

                    // Filter out already translated entries if needed
                    let entriesToTranslate = { ...sourceData };
                    let skippedCount = 0;

                    entriesToTranslate = Object.fromEntries(
                        Object.entries(sourceData).filter(([key, sourceText]) => {
                            const existingTranslation = originalTranslations[key];
                            
                            // Skip if entry has translation and we only want empty entries
                            if (onlyEmpty && existingTranslation && existingTranslation.trim() !== '') {
                                skippedCount++;
                                return false;
                            }
                            
                            // Skip if entry has translation in target language and ignoreTranslated is checked
                            if (ignoreTranslated && existingTranslation) {
                                const shouldTranslate = shouldTranslateEntry(sourceText, existingTranslation, targetLang);
                                if (!shouldTranslate) {
                                    skippedCount++;
                                    return false;
                                }
                            }
                            
                            return true;
                        })
                    );

                    // Initialize OpenAI client
                    openaiClient = new OpenAI({
                        apiKey: openaiApiKey,
                        dangerouslyAllowBrowser: true
                    });

                    // Set up current data
                    currentData = {
                        englishSource: entriesToTranslate,
                        originalTranslations: originalTranslations,
                        translations: {},
                        totalEntries: Object.keys(entriesToTranslate).length,
                        currentBatch: 0,
                        batchSize: batchSize,
                        targetLang: targetLang,
                        sourceLang: sourceLang,
                        processedKeys: new Set(),
                        multiLanguageTranslations: {},
                        processedLanguages: new Set(),
                        currentBatchProgress: 0,
                        translationQueue: [], // Store entries that need translation
                        translationResults: {} // Store completed translations for all languages
                    };

                    // Clear and set up table
                    const translationTable = document.getElementById('translationTable');
                    translationTable.innerHTML = '';
                    
                    // Add headers
                    updateTableHeaders();
                    
                    // Sort entries: entries to translate first (white), then skipped entries (gray)
                    const allEntries = Object.entries(sourceData);
                    const sortedEntries = allEntries.sort((a, b) => {
                        const aNeeds = entriesToTranslate.hasOwnProperty(a[0]) ? 0 : 1;
                        const bNeeds = entriesToTranslate.hasOwnProperty(b[0]) ? 0 : 1;
                        return aNeeds - bNeeds;
                    });

                    // Show all source entries and their translations (if they exist)
                    sortedEntries.forEach(([key, sourceText]) => {
                        const row = translationTable.insertRow();
                        row.id = `row-${key}`;
                        
                        // Key column
                        const keyCell = row.insertCell();
                        keyCell.textContent = key;
                        
                        // Source text column
                        const sourceCell = row.insertCell();
                        sourceCell.textContent = sourceText;
                        
                        // Original translation column
                        const originalCell = row.insertCell();
                        originalCell.textContent = originalTranslations[key] || '';
                        
                        // New translation column (empty for now)
                        const newCell = row.insertCell();
                        newCell.id = `translation-${key}`;
                        newCell.textContent = '';
                        
                        // If this entry is not in entriesToTranslate, gray out the row
                        if (!entriesToTranslate[key]) {
                            row.style.backgroundColor = '#f5f5f5';
                            row.style.color = '#999';
                        }
                    });

                    // Update UI state
                    startBtn.disabled = true;
                    const nextBtn = document.getElementById('nextBtn');
                    const saveBtn = document.getElementById('saveBtn');
                    nextBtn.disabled = currentData.totalEntries === 0;
                    saveBtn.disabled = false;

                    // Update statistics
                    updateStatistics();

                    const skippedMessage = skippedCount > 0 ? 
                        ` (${skippedCount} entries skipped as already translated)` : '';
                    showStatus(`Loaded ${currentData.totalEntries} entries${skippedMessage}. Click "Next Batch" to start translation.`, 'success');

                } catch (error) {
                    console.error('Error:', error);
                    showStatus('Error: ' + error.message, 'error');
                    startBtn.disabled = false;
                }
            });

            // Add change handlers for API key inputs
            document.getElementById('locoApiKey').addEventListener('change', savePreferences);
            document.getElementById('openaiApiKey').addEventListener('change', savePreferences);
            document.getElementById('batchSize').addEventListener('change', savePreferences);
            document.getElementById('ignoreBlank').addEventListener('change', savePreferences);

            // Add Next button handler
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.addEventListener('click', () => {
                processBatch();
            });

            // Single save button handler
            const saveBtn = document.getElementById('saveBtn');
            saveBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                
                // Prevent multiple clicks
                if (saveBtn.dataset.saving === 'true') return;
                saveBtn.dataset.saving = 'true';
                
                try {
                    showStatus('Preparing translations for download...', 'info');
                    
                    // Get all translations for current language from translationResults
                    const translations = {};
                    const rows = Array.from(document.getElementById('translationTable').getElementsByTagName('tr'));
                    
                    rows.forEach(row => {
                        if (!row.id) return; // Skip header row
                        const key = row.id.replace('row-', '');
                        const translationCell = document.getElementById(`translation-${key}`);
                        if (translationCell && translationCell.textContent.trim()) {
                            translations[key] = translationCell.textContent.trim();
                        }
                    });
                    
                    // Create export data with proper structure
                    const exportData = {
                        [currentData.targetLang]: unflattenObject(translations)
                    };

                    console.log('Final export data:', exportData);

                    // Create a Blob with the JSON data
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    
                    // Create a download link
                    const downloadLink = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    downloadLink.href = url;
                    downloadLink.download = `translations_${currentData.targetLang}_${new Date().toISOString().split('T')[0]}.json`;
                    
                    // Trigger the download
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    
                    // Cleanup
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                        document.body.removeChild(downloadLink);
                        saveBtn.dataset.saving = 'false';
                    }, 1000);
                    
                    showStatus('Translations downloaded successfully!', 'success');

                } catch (error) {
                    console.error('Error preparing download:', error);
                    showStatus('Error preparing download: ' + error.message, 'error');
                    saveBtn.dataset.saving = 'false';
                }
            });

            const modal = document.getElementById('apiModal');
            const configureBtn = document.getElementById('configureBtn');
            const closeBtn = document.querySelector('.close-modal');
            const saveApiKeysBtn = document.getElementById('saveApiKeys');

            // Add this function to handle API key display
            function formatApiKeyDisplay(apiKey) {
                if (!apiKey) return '';
                if (apiKey.length < 7) return apiKey; // If key is too short, show as is
                return `${apiKey.slice(0, 3)}...${apiKey.slice(-4)}`;
            }

            // Update the modal open handler to show masked key
            configureBtn.addEventListener('click', () => {
                modal.style.display = 'block';
                // Load saved OpenAI key if exists
                const openaiKey = localStorage.getItem('openaiApiKey');
                const openaiInput = document.getElementById('openaiApiKey');
                
                if (openaiKey) {
                    openaiInput.value = openaiKey;
                    openaiInput.setAttribute('data-full-key', openaiKey);
                    openaiInput.value = formatApiKeyDisplay(openaiKey);
                }
            });

            // Add input handler to manage key display/edit
            document.getElementById('openaiApiKey').addEventListener('focus', function() {
                const fullKey = this.getAttribute('data-full-key');
                if (fullKey) {
                    this.value = fullKey;
                }
            });

            document.getElementById('openaiApiKey').addEventListener('blur', function() {
                if (this.value.length > 0) {
                    this.setAttribute('data-full-key', this.value);
                    this.value = formatApiKeyDisplay(this.value);
                }
            });

            // Update save handler to use full key
            saveApiKeysBtn.addEventListener('click', () => {
                const openaiInput = document.getElementById('openaiApiKey');
                const openaiKey = openaiInput.getAttribute('data-full-key') || openaiInput.value;
                
                localStorage.setItem('openaiApiKey', openaiKey);
                modal.style.display = 'none';
                
                // Reinitialize OpenAI client with new key
                openaiClient = new OpenAI({
                    apiKey: openaiKey,
                    dangerouslyAllowBrowser: true
                });
                
                showStatus('OpenAI API key saved successfully', 'success');
            });

            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });

            window.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });

            const loadProjectBtn = document.getElementById('loadProjectBtn');
            loadProjectBtn.addEventListener('click', async () => {
                try {
                    const locoApiKey = document.getElementById('locoApiKey').value;
                    const filterCheckbox = document.getElementById('filterCheckbox').checked;

                    if (!locoApiKey) {
                        showStatus('Please enter your Localise API key', 'error');
                        return;
                    }

                    // Show loading status
                    showStatus('Loading project data...', 'info');

                    // Simple URL construction without any encoding
                    let url = `/api/translations?key=${locoApiKey}`;
                    if (filterCheckbox) {
                        url += '&filter=!sameassource';
                    }

                    console.log('DEBUG - Client request URL:', url);

                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log('DEBUG - Received data keys:', Object.keys(data).slice(0, 5));
                    // ... rest of the code

                    // Update statistics
                    const totalEntries = Object.keys(data['en-GB'] || {}).length;
                    document.getElementById('totalEntries').textContent = totalEntries;
                    document.getElementById('translatedEntries').textContent = '0';
                    document.getElementById('progressPercentage').textContent = '0%';
                    document.getElementById('progressFill').style.width = '0%';

                    // Store the data for later use
                    window.translationData = data;

                    showStatus('Project loaded successfully!', 'success');

                } catch (error) {
                    console.error('Error:', error);
                    showStatus('Error loading project: ' + error.message, 'error');
                }
            });

            // Add these functions before setupNavigationButtons
            const supportedLanguages = [
                'en-GB', 'de-DE', 'nl-NL', 'fr-FR', 'es-ES', 
                'it-IT', 'ro-RO', 'cs-CZ', 'bg-BG', 'el-GR', 
                'hu-HU', 'zh-CN'
            ];

            function getNextLanguage(currentLang) {
                const currentIndex = supportedLanguages.indexOf(currentLang);
                return supportedLanguages[(currentIndex + 1) % supportedLanguages.length];
            }

            function getPreviousLanguage(currentLang) {
                const currentIndex = supportedLanguages.indexOf(currentLang);
                return supportedLanguages[(currentIndex - 1 + supportedLanguages.length) % supportedLanguages.length];
            }

            function updateTargetLanguage(newLang) {
                // Update the target language selection in the grid
                document.querySelectorAll('#targetLangGrid .lang-button').forEach(btn => {
                    btn.dataset.selected = btn.dataset.lang === newLang ? 'true' : 'false';
                });
                
                // Update currentData target language
                currentData.targetLang = newLang;
                
                // Get original translations from Localise API
                const originalTranslations = window.translationData && window.translationData[newLang] ? 
                    flattenObject(window.translationData[newLang]) : {};
                console.log('Flattened original translations:', originalTranslations);
                
                // Get our new translations
                const newTranslations = currentData.translationResults?.[newLang] || {};
                console.log('New translations for this language:', newTranslations);
                
                // Get checkbox states
                const ignoreTranslated = document.getElementById('ignoreTranslated').checked;
                const onlyEmpty = document.getElementById('onlyEmpty').checked;
                
                // Show translations for the new language
                const translationTable = document.getElementById('translationTable');
                const rows = translationTable.getElementsByTagName('tr');
                
                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    if (!row.id) continue; // Skip header row
                    
                    const key = row.id.replace('row-', '');
                    
                    // Update original translation column from Localise API
                    const cells = row.getElementsByTagName('td');
                    if (cells.length >= 3) {
                        const originalCell = cells[2];
                        const originalTranslation = originalTranslations[key] || '';
                        console.log(`Setting original translation for ${key}:`, originalTranslation);
                        originalCell.textContent = originalTranslation;
                    }
                    
                    // Update new translation column from our translations
                    const translationCell = document.getElementById(`translation-${key}`);
                    if (translationCell) {
                        const newTranslation = newTranslations[key] || '';
                        console.log(`Setting new translation for ${key}:`, newTranslation);
                        translationCell.textContent = newTranslation;
                        
                        // Determine if this row should be grayed out based on checkbox states
                        const hasOriginalTranslation = !!originalTranslations[key];
                        const isEmpty = !originalTranslations[key] && !newTranslation;
                        
                        if (hasOriginalTranslation && ignoreTranslated) {
                            // Gray out if we're ignoring already translated entries
                            row.style.backgroundColor = '#f5f5f5';
                            row.style.color = '#999';
                        } else if (!isEmpty && onlyEmpty) {
                            // Gray out if we're only translating empty entries and this one isn't empty
                            row.style.backgroundColor = '#f5f5f5';
                            row.style.color = '#999';
                        } else {
                            // Reset styling for entries that need translation
                            row.style.backgroundColor = '';
                            row.style.color = '';
                        }
                    }
                }
                
                // Update currentData with new counts
                currentData.totalEntries = Object.keys(newTranslations).length;
                
                // Enable/disable Next Batch button based on remaining translations
                const nextBtn = document.getElementById('nextBtn');
                if (nextBtn) {
                    nextBtn.disabled = Object.keys(newTranslations).length === 0;
                }
                
                // Update statistics display
                const statsDisplay = document.getElementById('statsDisplay');
                if (statsDisplay) {
                    statsDisplay.textContent = `Entries to translate: ${Object.keys(newTranslations).length} / Total entries: ${Object.keys(newTranslations).length}`;
                }
                
                // Save preferences
                savePreferences();
            }

            // Add event listeners in your DOMContentLoaded handler
            document.addEventListener('DOMContentLoaded', () => {
                // Initialize language buttons
                initLanguageButtons();
                
                // Load saved preferences
                loadSavedPreferences();

                // Add navigation button handlers with console logs
                const prevBtn = document.getElementById('prevLang');
                const nextBtn = document.getElementById('nextLang');
                
                console.log('Navigation buttons:', { prevBtn, nextBtn });

                prevBtn.addEventListener('click', () => {
                    console.log('Previous button clicked');
                    const currentLang = getSelectedLanguage('targetLangGrid');
                    console.log('Current language:', currentLang);
                    const prevLang = getPreviousLanguage(currentLang);
                    console.log('Switching to previous language:', prevLang);
                    updateTargetLanguage(prevLang);
                });
                
                nextBtn.addEventListener('click', () => {
                    console.log('Next button clicked');
                    const currentLang = getSelectedLanguage('targetLangGrid');
                    console.log('Current language:', currentLang);
                    const nextLang = getNextLanguage(currentLang);
                    console.log('Switching to next language:', nextLang);
                    updateTargetLanguage(nextLang);
                });
                
                // Update initial language display
                const initialLang = getSelectedLanguage('targetLangGrid');
                const initialLangButton = document.querySelector(`#targetLangGrid .lang-button[data-lang="${initialLang}"]`);
                if (initialLangButton) {
                    document.getElementById('currentTargetLang').textContent = initialLangButton.getAttribute('title');
                }
            });
        });

        function initLanguageButtons() {
            // Source language buttons
            document.querySelectorAll('#sourceLangGrid .lang-button').forEach(button => {
                button.addEventListener('click', () => {
                    // Update visual state
                    document.querySelectorAll('#sourceLangGrid .lang-button').forEach(btn => {
                        btn.dataset.selected = 'false';
                    });
                    button.dataset.selected = 'true';
                    
                    // Update data and UI
                    currentData.sourceLang = button.dataset.lang;
                    updateTableHeaders();
                    savePreferences();
                });
            });

            // Target language buttons
            document.querySelectorAll('#targetLangGrid .lang-button').forEach(button => {
                button.addEventListener('click', () => {
                    // Use our existing updateTargetLanguage function
                    updateTargetLanguage(button.dataset.lang);
                });
            });
        }

        // Add status display function
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            if (!statusDiv) {
                console.error('Status element not found');
                return;
            }
            
            statusDiv.textContent = message;
            statusDiv.className = 'status-message ' + type;
            
            // Optionally auto-hide success messages after 3 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

        // Add translateText function
        function getGlossaryPrompt(text, targetLang) {
            console.log('Checking glossary for:', text);
            console.log('Target language:', targetLang);
            console.log('Available glossary:', window.glossary);

            // Convert language codes
            const langMapping = {
                'en-GB': 'en-GB',
                'fr-FR': 'fr-FR',
                'de-DE': 'de-DE',
                'nl-NL': 'nl-NL',
                'it-IT': 'it-IT',
                'hu-HU': 'hu-HU',
                'cs-CZ': 'cs-CZ',
                'ro-RO': 'ro-RO',
                'bg-BG': 'bg-BG',
                'es-ES': 'es-ES',
                'zh-CN': 'zh-CN'
            };

            const langCode = langMapping[targetLang];
            console.log('Mapped language code:', langCode);
            
            if (!langCode || !window.glossary) {
                console.log('Missing langCode or glossary:', { langCode, hasGlossary: !!window.glossary });
                return '';
            }

            // Find matching glossary terms
            const matches = Object.entries(window.glossary).filter(([key]) => {
                const term = key.toLowerCase();
                const textLower = text.toLowerCase();
                const isMatch = textLower.includes(term) || 
                               textLower.includes(term + 's') || 
                               textLower.includes(term + "'s") || 
                               (term === 'you' && textLower.includes('your'));
                console.log(`Checking term "${term}" against "${textLower}":`, isMatch);
                return isMatch;
            });

            console.log('Found matches:', matches);

            if (matches.length === 0) return '';

            // Build prompt addition
            const translations = matches.map(([key, translations]) => {
                const translation = translations[langCode];
                // Check if translation is empty or undefined
                if (!translation) {
                    console.log(`Ignoring empty or undefined translation for ${key}`);
                    return null; // Return null to filter out
                }
                console.log(`Getting translation for ${key}:`, translation);
                return `"${key}": "${translation}"`;
            }).filter(Boolean); // Filter out null values

            // Only include the glossary prompt if there are valid translations
            const prompt = translations.length > 0 
                ? `Please keep in mind the following glossary: ${translations.join(', ')}. ` 
                : ''; // Empty prompt if no valid translations

            console.log('Final glossary prompt:', prompt);
            return prompt;
        }

        async function translateText(text, targetLang) {
            try {
                // Get glossary prompt
                const glossaryPrompt = getGlossaryPrompt(text, targetLang);
                
                const completion = await openaiClient.chat.completions.create({
                    messages: [
                        {
                            role: "system",
                            content: `You are a professional translator for a B2B foreign exchange and cross-border payments platform. Translate to ${targetLang}. Important rules:
                            1. ${glossaryPrompt}
                            2. Adapt the case, gender, number, and declination of any glossary terms for grammatical correctness
                            3. Preserve ALL variables without translation: %variable%, %%variable%%, {{variable}}
                            4. ONLY include HTML tags that exist in the original text - DO NOT add new ones
                            5. Keep existing HTML tags (<br>, <p>, etc.) exactly as they appear
                            6. DO NOT translate: HTML tags, URLs, date formats like DD/MM/YYYY HH:mm or similar
                            Context: The platform handles currency conversion, international payments, and financial operations for business clients.`
                        },
                        {
                            role: "user",
                            content: `The text to translate is: ${text}`
                        }
                    ],
                    model: "gpt-4o-mini",
                });

                let translatedText = completion.choices[0].message.content.trim();
                
                // Remove "The text to translate is:" if it appears in the response
                translatedText = translatedText.replace(/^The text to translate is:\s*/i, '');
                
                return translatedText;
            } catch (error) {
                console.error('Translation error:', error);
                throw new Error(`Translation failed: ${error.message}`);
            }
        }

        // Add this to your global variables
        const SUPPORTED_LANGUAGES = {
            'en-GB': 'eng',  // English
            'de-DE': 'deu',  // German
            'nl-NL': 'nld',  // Dutch
            'fr-FR': 'fra',  // French
            'es-ES': 'spa',  // Spanish
            'it-IT': 'ita',  // Italian
            'ro-RO': 'ron',  // Romanian
            'cs-CZ': 'ces',  // Czech
            'bg-BG': 'bul',  // Bulgarian
            'el-GR': 'ell',  // Greek
            'hu-HU': 'hun',  // Hungarian
            'zh-CN': 'cmn'   // Chinese
        };

        // Add language detection function
        function detectLanguage(text) {
            // Wait for franc to be available
            if (typeof window.franc === 'undefined') {
                console.error('Franc not loaded yet');
                return null;
            }
            
            if (!text || text.trim().length < 10) {
                console.log('Text too short for detection:', text);
                return null;
            }
            
            try {
                const detectedLang = window.franc(text, {
                    only: Object.values(SUPPORTED_LANGUAGES),
                    minLength: 1
                });
                
                // Simpler debug output without franc.all
                console.log('Language Detection Debug:', {
                    text: text,
                    detectedCode: detectedLang,
                    textLength: text.length,
                    supportedLanguages: Object.values(SUPPORTED_LANGUAGES)
                });
                
                const detectedLocale = Object.keys(SUPPORTED_LANGUAGES).find(
                    locale => SUPPORTED_LANGUAGES[locale] === detectedLang
                );
                
                console.log('Detected locale:', detectedLocale);
                return detectedLocale;
            } catch (error) {
                console.error('Language detection error:', error);
                return null;
            }
        }

        // Update the translation process to skip already translated entries
        function shouldTranslateEntry(sourceText, existingTranslation, targetLang) {
            // If no existing translation, always translate
            if (!existingTranslation) return true;
            
            // Detect language of existing translation
            const detectedLang = detectLanguage(existingTranslation);
            
            // If we can't detect the language (too short/ambiguous) or 
            // if detected language doesn't match target language, translate it
            if (!detectedLang || detectedLang !== targetLang) return true;
            
            // If ignore translated is checked and text is in target language, skip it
            return !document.getElementById('ignoreTranslated').checked;
        }

        // Update processBatch function
        async function processBatch() {
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.classList.add('loading');
            nextBtn.textContent = 'Translating...';
            
            try {
                const translateAll = document.getElementById('translateAll').checked;
                
                // Initialize translation queue if empty
                if (currentData.translationQueue.length === 0) {
                    currentData.translationQueue = Object.entries(currentData.englishSource)
                        .filter(([key]) => !currentData.processedKeys.has(key));
                }
                
                // Get next batch of entries
                const entries = currentData.translationQueue.slice(0, currentData.batchSize);

                if (translateAll) {
                    // Initialize storage for all languages
                    if (!currentData.translationResults) {
                        currentData.translationResults = {};
                    }

                    // Get all target languages except source
                    const targetLanguages = supportedLanguages.filter(lang => 
                        lang !== currentData.sourceLang && 
                        document.querySelector(`#targetLangGrid .lang-button[data-lang="${lang}"]`)
                    );

                    // Initialize storage for each language
                    targetLanguages.forEach(lang => {
                        if (!currentData.translationResults[lang]) {
                            currentData.translationResults[lang] = {};
                        }
                    });

                    // Process each entry for all languages
                    for (const [key, sourceText] of entries) {
                        showStatus(`Translating entry ${currentData.processedKeys.size + 1}/${currentData.totalEntries} to all languages...`, 'info');
                        
                        for (const targetLang of targetLanguages) {
                            try {
                                const translation = await translateText(sourceText, targetLang);
                                
                                // Store in results
                                currentData.translationResults[targetLang][key] = translation;
                                
                                // Update UI if this is the current target language
                                if (targetLang === currentData.targetLang) {
                                    const cell = document.getElementById(`translation-${key}`);
                                    if (cell) cell.textContent = translation;
                                }
                                
                                // Update progress
                                currentData.processedLanguages.add(targetLang);
                                
                            } catch (error) {
                                console.error(`Error translating to ${targetLang}:`, error);
                                showStatus(`Error translating to ${targetLang}: ${error.message}`, 'error');
                            }
                        }
                        
                        currentData.processedKeys.add(key);
                        // Remove processed entry from queue
                        currentData.translationQueue = currentData.translationQueue.filter(([k]) => k !== key);
                        updateStatistics();
                    }
                } else {
                    // Single language translation
                    if (!currentData.translationResults[currentData.targetLang]) {
                        currentData.translationResults[currentData.targetLang] = {};
                    }

                    for (const [key, sourceText] of entries) {
                        showStatus(`Translating entry ${currentData.processedKeys.size + 1}/${currentData.totalEntries}...`, 'info');
                        const translation = await translateText(sourceText, currentData.targetLang);
                        
                        // Store translation
                        currentData.translationResults[currentData.targetLang][key] = translation;
                        
                        // Update UI
                        const cell = document.getElementById(`translation-${key}`);
                        if (cell) cell.textContent = translation;
                        
                        currentData.processedKeys.add(key);
                        // Remove processed entry from queue
                        currentData.translationQueue = currentData.translationQueue.filter(([k]) => k !== key);
                        updateStatistics();
                    }
                }

                // Update UI state
                const saveBtn = document.getElementById('saveBtn');
                saveBtn.disabled = false;
                nextBtn.disabled = currentData.translationQueue.length === 0;
                
                if (currentData.translationQueue.length === 0) {
                    showStatus('All translations completed!', 'success');
                }

                // Update progress bar
                const progress = ((currentData.totalEntries - currentData.translationQueue.length) / currentData.totalEntries) * 100;
                document.getElementById('progressFill').style.width = `${progress}%`;
                document.getElementById('progressPercentage').textContent = `${Math.round(progress)}%`;

            } catch (error) {
                console.error('Batch processing error:', error);
                showStatus('Error processing batch: ' + error.message, 'error');
            } finally {
                nextBtn.classList.remove('loading');
                nextBtn.textContent = 'Next Batch';
            }
        }

        // Add statistics update function
        function updateStatistics() {
            const totalEntries = Object.keys(currentData.englishSource || {}).length;
            const translatedEntries = currentData.processedKeys.size;
            const progressPercentage = totalEntries ? Math.round((translatedEntries / totalEntries) * 100) : 0;

            document.getElementById('totalEntries').textContent = totalEntries;
            document.getElementById('translatedEntries').textContent = translatedEntries;
            document.getElementById('progressPercentage').textContent = `${progressPercentage}%`;
            document.getElementById('progressFill').style.width = `${progressPercentage}%`;
        }

        // Add helper function to flatten nested objects
        function flattenObject(obj, prefix = '') {
            return Object.keys(obj).reduce((acc, key) => {
                const pre = prefix.length ? prefix + '.' : '';
                if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
                    Object.assign(acc, flattenObject(obj[key], pre + key));
                } else {
                    acc[pre + key] = obj[key];
                }
                return acc;
            }, {});
        }

        // Add helper function to unflatten object for export
        function unflattenObject(obj) {
            const result = {};
            
            for (const key in obj) {
                const keys = key.split('.');
                let current = result;
                
                for (let i = 0; i < keys.length - 1; i++) {
                    current[keys[i]] = current[keys[i]] || {};
                    current = current[keys[i]];
                }
                
                current[keys[keys.length - 1]] = obj[key];
            }
            
            return result;
        }
    </script> 
</body>
</html> 