<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INDY - AI Translator</title>
    <!-- Import as ES module -->
    <script type="module">
        import OpenAI from 'https://cdn.jsdelivr.net/npm/openai@4.28.0/+esm'
        window.OpenAI = OpenAI;
    </script>
    <link rel="stylesheet" href="styles.css">
    <script type="module">
        // Import franc
        import { franc } from 'https://esm.sh/franc@6?bundle';
        
        // Make franc available globally since our other code needs it
        window.franc = franc;
    </script>
    <script>
        // Fetch the glossary file
        fetch('./glossary.json')
            .then(response => response.json())
            .then(data => {
                window.glossary = data;
                console.log('Glossary loaded:', window.glossary);
            })
            .catch(error => console.error('Error loading glossary:', error));
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600&family=Ruda:wght@400;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cg transform='matrix(-1,0,0,1,32,0) scale(0.015625)'%3E%3Cpath fill='%23CC3333' transform='translate(1153)' d='m0 0h142l-7 12-7 10-34 51-7 11 56-8 49-5 42-3 54-2h84l-2 5-13 22-17 28-11 19-12 20-17 28-15 25h81l74 6 52 6 112 14 4 2-6 8-8 11-14 19-16 21-11 14-9 11-11 13-7 8-16 17-13 14-8 7-15 14-11 10-28 22-9 7 9 2 38 6 45 10 28 8 36 12 44 17 86 37 58 25 1 4-10 9-148 148 16 8 26 12 44 24 17 11 21 14 19 14 13 10 14 11 12 9 1 4-185 185-6 7-5 4v2l10 8 14 12 11 9 16 15 28 28 9 11 10 11 9 11 12 15 12 17 13 18 10 15 9 13v3l-32 14-147 63-33 14-5 1 3 5 9 10 11 12 7 8 12 14 13 17 10 12 14 19 14 20 9 13 15 24 12 20 10 17 10 18 9 15-1 3h-28l-56-1-30-2-39-4-41-7-41-9-7-1 14 49 45 157 4 13v4l-2 1h-235l10 35 6 26 5 29 4 38 1 19v65l-6-1-47-16-34-13-39-18-28-15-17-10-22-14-6-4v143l-1 2h-41l-38-3-34-7-20-6-27-10-28-14-16-10-23-16-11-10-8-7-10-9-9-9-9-11-11-13-14-21-8-13v-2h-2l-2 9-10 35-8 20-14 30-6 11-12 19-10 15-6 8-11 13-9 10-9 11-27 27h-3l-7-8-10-10v-2h-2l-7-8-9-9-7-8-8-9-11-14-14-19-16-25-12-22-8-15-14-32-11-31-9-34-8-44-6-43-4-38-2-35v-8l-93 1-191 82-20 8-19 6-19 3-19 1-26-3-20-6-17-8-12-8-11-9-10-10-11-15-7-12-6-15-4-14-2-12v-25l3-18 8-26 8-25 1-195h-99l-1-1v-43l2-26 5-29 7-25 8-22 8-18 12-23 7-11 13-18 8-10 18-21h2v-2l8-7 10-9 6-5-2-4-55-55 1-6h2l2-4 14-19 10-13 14-19 10-13 14-19 10-13 14-19 2-3-1-5-6-10-6-14-3-13-1-15 2-17 4-15 8-16 8-11 11-14 9-11 11-14 10-12 10-13 9-11 8-10 11-14 13-16 5-7h2l2-4 12-12 17-11 17-7 14-4 7-7 5-7h2l2-4 12-14 9-11 8-9 9-11 2-3h2l2-4 13-15 9-11 12-14 6-8h2l2-4 13-15 9-11 12-14 6-8h2l2-4 12-14 22-26 6-8h2l2-4 12-14 9-11 8-9 9-11 2-3h2l2-4 13-15 8-10 8-9 9-11 2-3h2l2-4 12-14 9-11 8-9 9-11 2-3h2l2-4 13-14 7-8 12-13 18-18h2v-2l8-7 11-10 11-9 18-14 12-9 14-10 24-15 21-13 22-11 19-10 36-15 25-9 35-11 30-7 29-6 48-7z'/%3E%3Cpath fill='%23CC3333' transform='translate(365,1033)' d='m0 0h67l1 2v64l-2 2h-65l-1-1z'/%3E%3C/g%3E%3C/svg%3E">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo">
                <svg class="logo-img" width="32" height="32" viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" transform="matrix(-1,0,0,1,0,0)">
                    <path transform="translate(1153)" d="m0 0h142l-7 12-7 10-34 51-7 11 56-8 49-5 42-3 54-2h84l-2 5-13 22-17 28-11 19-12 20-17 28-15 25h81l74 6 52 6 112 14 4 2-6 8-8 11-14 19-16 21-11 14-9 11-11 13-7 8-16 17-13 14-8 7-15 14-11 10-28 22-9 7 9 2 38 6 45 10 28 8 36 12 44 17 86 37 58 25 1 4-10 9-148 148 16 8 26 12 44 24 17 11 21 14 19 14 13 10 14 11 12 9 1 4-185 185-6 7-5 4v2l10 8 14 12 11 9 16 15 28 28 9 11 10 11 9 11 12 15 12 17 13 18 10 15 9 13v3l-32 14-147 63-33 14-5 1 3 5 9 10 11 12 7 8 12 14 13 17 10 12 14 19 14 20 9 13 15 24 12 20 10 17 10 18 9 15-1 3h-28l-56-1-30-2-39-4-41-7-41-9-7-1 14 49 45 157 4 13v4l-2 1h-235l10 35 6 26 5 29 4 38 1 19v65l-6-1-47-16-34-13-39-18-28-15-17-10-22-14-6-4v143l-1 2h-41l-38-3-34-7-20-6-27-10-28-14-16-10-23-16-11-10-8-7-10-9-9-9-9-11-11-13-14-21-8-13v-2h-2l-2 9-10 35-8 20-14 30-6 11-12 19-10 15-6 8-11 13-9 10-9 11-27 27h-3l-7-8-10-10v-2h-2l-7-8-9-9-7-8-8-9-11-14-14-19-16-25-12-22-8-15-14-32-11-31-9-34-8-44-6-43-4-38-2-35v-8l-93 1-191 82-20 8-19 6-19 3-19 1-26-3-20-6-17-8-12-8-11-9-10-10-11-15-7-12-6-15-4-14-2-12v-25l3-18 8-26 8-25 1-195h-99l-1-1v-43l2-26 5-29 7-25 8-22 8-18 12-23 7-11 13-18 8-10 18-21h2v-2l8-7 10-9 6-5-2-4-55-55 1-6h2l2-4 14-19 10-13 14-19 10-13 14-19 10-13 14-19 2-3-1-5-6-10-6-14-3-13-1-15 2-17 4-15 8-16 8-11 11-14 9-11 11-14 10-12 10-13 9-11 8-10 11-14 13-16 5-7h2l2-4 12-12 17-11 17-7 14-4 7-7 5-7h2l2-4 12-14 9-11 8-9 9-11 2-3h2l2-4 13-15 9-11 12-14 6-8h2l2-4 13-15 9-11 12-14 6-8h2l2-4 12-14 22-26 6-8h2l2-4 12-14 9-11 8-9 9-11 2-3h2l2-4 13-15 8-10 8-9 9-11 2-3h2l2-4 12-14 9-11 8-9 9-11 2-3h2l2-4 13-14 7-8 12-13 18-18h2v-2l8-7 11-10 11-9 18-14 12-9 14-10 24-15 21-13 22-11 19-10 36-15 25-9 35-11 30-7 29-6 48-7z"/>
                    <path transform="translate(365,1033)" d="m0 0h67l1 2v64l-2 2h-65l-1-1z"/>
                    <path transform="translate(888,1828)" d="m0 0"/>
                    <path transform="translate(760,1811)" d="m0 0"/>
                    <path transform="translate(780,1203)" d="m0 0"/>
                </svg>
                <span class="logo-text">INDY.tradutor</span>
            </div>
            <div class="header-controls">
                <div class="api-input-group">
                    <label for="locoApiKey">Loco Project API Key:</label>
                    <input type="password" id="locoApiKey" placeholder="Enter your Localise API key">
                    <button id="loadProjectBtn" class="icon-button" title="Load Project">
                        <span class="material-icons">cloud_upload</span>
                    </button>
                </div>
                <div class="api-input-group">
                    <select id="projectSelect" class="project-select">
                        <option value="">Select a project...</option>
                    </select>
                    <button id="addProjectBtn" class="icon-button" title="Add Project">
                        <span class="material-icons">add</span>
                    </button>
                </div>
                <button id="configureBtn" class="icon-button" title="OpenAI API Key">
                    <span class="material-icons">settings</span>
                </button>
            </div>
        </div>
    </div>

    <div id="status" class="status-message"></div>

    <style>
        .status-message {
            margin: 16px auto;
            padding: 12px 24px;
            border-radius: 8px;
            max-width: 1200px;
            display: none;
        }

        .status-message.info {
            background-color: #e3f2fd;
            color: #1976d2;
            display: block;
        }

        .status-message.success {
            background-color: #e8f5e9;
            color: #2e7d32;
            display: block;
        }

        .status-message.error {
            background-color: #ffebee;
            color: #c62828;
            display: block;
        }
    </style>

    <div class="setup-container">
        <div class="setup-grid">
            <div class="setup-column">
                <div>
                    <h4>Source Language:</h4>
                    <div class="language-grid" id="sourceLangGrid">
                        <!-- Germanic languages -->
                        <button type="button" class="lang-button" data-lang="en-GB" data-selected="true" title="English">
                            <img src="https://flagcdn.com/w20/gb.png" alt="English">
                        </button>
                        <button type="button" class="lang-button" data-lang="de-DE" title="German">
                            <img src="https://flagcdn.com/w20/de.png" alt="German">
                        </button>
                        <button type="button" class="lang-button" data-lang="nl-NL" title="Dutch">
                            <img src="https://flagcdn.com/w20/nl.png" alt="Dutch">
                        </button>

                        <!-- Romance languages -->
                        <button type="button" class="lang-button" data-lang="fr-FR" title="French">
                            <img src="https://flagcdn.com/w20/fr.png" alt="French">
                        </button>
                        <button type="button" class="lang-button" data-lang="es-ES" title="Spanish">
                            <img src="https://flagcdn.com/w20/es.png" alt="Spanish">
                        </button>
                        <button type="button" class="lang-button" data-lang="it-IT" title="Italian">
                            <img src="https://flagcdn.com/w20/it.png" alt="Italian">
                        </button>
                        <button type="button" class="lang-button" data-lang="ro-RO" title="Romanian">
                            <img src="https://flagcdn.com/w20/ro.png" alt="Romanian">
                        </button>

                        <!-- Slavic languages -->
                        <button type="button" class="lang-button" data-lang="cs-CZ" title="Czech">
                            <img src="https://flagcdn.com/w20/cz.png" alt="Czech">
                        </button>
                        <button type="button" class="lang-button" data-lang="bg-BG" title="Bulgarian">
                            <img src="https://flagcdn.com/w20/bg.png" alt="Bulgarian">
                        </button>
                        <button type="button" class="lang-button" data-lang="pl-PL" title="Polish">
                            <img src="https://flagcdn.com/w20/pl.png" alt="Polish">
                        </button>

                        <!-- Other Indo-European -->
                        <button type="button" class="lang-button" data-lang="el-GR" title="Greek">
                            <img src="https://flagcdn.com/w20/gr.png" alt="Greek">
                        </button>

                        <!-- Uralic languages -->
                        <button type="button" class="lang-button" data-lang="hu-HU" title="Hungarian">
                            <img src="https://flagcdn.com/w20/hu.png" alt="Hungarian">
                        </button>

                        <!-- East Asian languages -->
                        <button type="button" class="lang-button" data-lang="zh-CN" title="Chinese">
                            <img src="https://flagcdn.com/w20/cn.png" alt="Chinese">
                        </button>
                    </div>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="ignoreBlank" checked>
                        Ignore blank source entries
                    </label>
                </div>
            </div>
            <div class="setup-column">
                <div>
                    <h4>Target Language:</h4>
                    <div class="language-grid" id="targetLangGrid">
                        <!-- Germanic languages -->
                        <button type="button" class="lang-button" data-lang="en-GB" title="English">
                            <img src="https://flagcdn.com/w20/gb.png" alt="English">
                        </button>
                        <button type="button" class="lang-button" data-lang="de-DE" title="German">
                            <img src="https://flagcdn.com/w20/de.png" alt="German">
                        </button>
                        <button type="button" class="lang-button" data-lang="nl-NL" title="Dutch">
                            <img src="https://flagcdn.com/w20/nl.png" alt="Dutch">
                        </button>

                        <!-- Romance languages -->
                        <button type="button" class="lang-button" data-lang="fr-FR" title="French">
                            <img src="https://flagcdn.com/w20/fr.png" alt="French">
                        </button>
                        <button type="button" class="lang-button" data-lang="es-ES" title="Spanish">
                            <img src="https://flagcdn.com/w20/es.png" alt="Spanish">
                        </button>
                        <button type="button" class="lang-button" data-lang="it-IT" title="Italian">
                            <img src="https://flagcdn.com/w20/it.png" alt="Italian">
                        </button>
                        <button type="button" class="lang-button" data-lang="ro-RO" title="Romanian">
                            <img src="https://flagcdn.com/w20/ro.png" alt="Romanian">
                        </button>

                        <!-- Slavic languages -->
                        <button type="button" class="lang-button" data-lang="cs-CZ" title="Czech">
                            <img src="https://flagcdn.com/w20/cz.png" alt="Czech">
                        </button>
                        <button type="button" class="lang-button" data-lang="bg-BG" title="Bulgarian">
                            <img src="https://flagcdn.com/w20/bg.png" alt="Bulgarian">
                        </button>
                        <button type="button" class="lang-button" data-lang="pl-PL" title="Polish">
                            <img src="https://flagcdn.com/w20/pl.png" alt="Polish">
                        </button>

                        <!-- Other Indo-European -->
                        <button type="button" class="lang-button" data-lang="el-GR" title="Greek">
                            <img src="https://flagcdn.com/w20/gr.png" alt="Greek">
                        </button>

                        <!-- Uralic languages -->
                        <button type="button" class="lang-button" data-lang="hu-HU" title="Hungarian">
                            <img src="https://flagcdn.com/w20/hu.png" alt="Hungarian">
                        </button>

                        <!-- East Asian languages -->
                        <button type="button" class="lang-button" data-lang="zh-CN" title="Chinese">
                            <img src="https://flagcdn.com/w20/cn.png" alt="Chinese">
                        </button>
                    </div>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="ignoreTranslated">
                        Ignore entries already translated in target language
                    </label>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="onlyEmpty">
                        Only translate empty entries
                    </label>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="translateAll">
                        Translate to all target languages at once
                    </label>
                </div>
                <div class="filter-group">
                    <input type="checkbox" id="filterCheckbox">
                    <label for="filterCheckbox">Ignore entries with tag "sameassource"</label>
                </div>
            </div>
        </div>
    </div>

    
    <div class="stats-container">
        <div class="stats-grid">
            <div class="stat-item">
                <label>Total Entries:</label>
                <span id="totalEntries">0</span>
            </div>
            <div class="stat-item">
                <label>Translated Entries:</label>
                <span id="translatedEntries">0</span>
            </div>
        </div>
        <div class="progress-container">
            <div class="progress">
                <div class="progress-fill" id="progressFill">
                    <span id="progressPercentage">0%</span>
                </div>
            </div>
        </div>
    </div>

    <div class="control-panel">
        <div class="batch-size-container">
            <input type="number" 
                   id="batchSize" 
                   class="input-with-tooltip" 
                   placeholder="Batch size" 
                   title="Batch size" 
                   min="1" 
                   value="1000">
        </div>
        <button id="startBtn">Start</button>
        <button id="nextBtn" disabled>Next Batch</button>
        <button class="icon-button" title="Save translations" id="saveBtn">
            <span class="material-icons">save</span>
        </button>
    </div>

    <table>
        <thead>
            <tr>
                <th colspan="4" class="language-navigation">
                    <div class="language-nav-container">
                        <button class="lang-nav-btn" id="prevLang">←</button>
                        <span id="currentTargetLang"></span>
                        <button class="lang-nav-btn" id="nextLang">→</button>
                    </div>
                </th>
            </tr>
            <tr>
                <th>Asset ID</th>
                <th id="sourceHeader">English (Source)</th>
                <th id="targetHeader1">Original Translation</th>
                <th id="targetHeader2">New Translation</th>
            </tr>
        </thead>
        <tbody id="translationTable">
            <!-- Translations will be inserted here -->
        </tbody>
    </table>

    <div id="apiModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>OpenAI API Configuration</h2>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="input-group">
                    <label for="openaiApiKey">OpenAI API Key</label>
                    <input type="password" id="openaiApiKey" placeholder="Enter your OpenAI API key">
                </div>
            </div>
            <div class="modal-footer">
                <button id="saveApiKeys" class="save-btn">Save Configuration</button>
            </div>
        </div>
    </div>

    <!-- Replace the existing project modal HTML -->
    <div id="projectModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Project Configuration</h2>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="projectForm">
                    <div class="input-group">
                        <label for="projectName">Project Name</label>
                        <input type="text" id="projectName" required>
                    </div>
                    <div class="input-group">
                        <label for="readOnlyKey">Read-only API Key</label>
                        <input type="password" id="readOnlyKey" required>
                    </div>
                    <div class="input-group">
                        <label for="writeKey">Write API Key</label>
                        <input type="password" id="writeKey" required>
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="save-btn">Save Project</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <script>
        // Initialize all global variables
        let currentData = {
            englishSource: {},
            originalTranslations: {},
            translations: {},
            totalEntries: 0,
            currentBatch: 0,
            batchSize: 10,
            targetLang: '',
            sourceLang: 'en-GB',
            processedKeys: new Set(),
            multiLanguageTranslations: {},
            processedLanguages: new Set(),
            currentBatchProgress: 0,
            translationQueue: [], // Store entries that need translation
            translationResults: {} // Store completed translations for all languages
        };
        
        let openaiClient = null;

        // Add this flag at the top with other global variables
        let isSaving = false;

        // Define all necessary functions
        function savePreferences() {
            const preferences = {
                sourceLang: getSelectedLanguage('sourceLangGrid'),
                targetLang: getSelectedLanguage('targetLangGrid'),
                batchSize: document.getElementById('batchSize').value,
                ignoreBlank: document.getElementById('ignoreBlank').checked,
                ignoreTranslated: document.getElementById('ignoreTranslated').checked,
                onlyEmpty: document.getElementById('onlyEmpty').checked,
                locoApiKey: document.getElementById('locoApiKey').value,
                filterCheckbox: document.getElementById('filterCheckbox').checked,
            };
            localStorage.setItem('translationPreferences', JSON.stringify(preferences));
        }

        function getSelectedLanguage(gridId) {
            const selectedButton = document.querySelector(`#${gridId} .lang-button[data-selected="true"]`);
            console.log('Getting selected language for', gridId, ':', selectedButton?.dataset.lang);
            return selectedButton ? selectedButton.dataset.lang : null;
        }

        function getSelectedLanguageName(gridId) {
            const selectedButton = document.querySelector(`#${gridId} .lang-button[data-selected="true"]`);
            console.log('Getting selected language name for', gridId, ':', selectedButton?.textContent.trim());
            return selectedButton ? selectedButton.textContent.trim() : null;
        }

        function updateTableHeaders() {
            const sourceLangButton = document.querySelector('#sourceLangGrid .lang-button[data-selected="true"]');
            const targetLangButton = document.querySelector('#targetLangGrid .lang-button[data-selected="true"]');
            
            if (sourceLangButton && targetLangButton) {
                const sourceLangName = sourceLangButton.getAttribute('title');
                const targetLangName = targetLangButton.getAttribute('title');
                
                document.getElementById('sourceHeader').textContent = `${sourceLangName} (Source)`;
                document.getElementById('targetHeader1').textContent = `${targetLangName} (Original Translation)`;
                document.getElementById('targetHeader2').textContent = `${targetLangName} (New Translation)`;
            }
        }

        function loadSavedPreferences() {
            try {
                const savedPreferences = JSON.parse(localStorage.getItem('translationPreferences')) || {};
                console.log('Loading saved preferences:', { ...savedPreferences, locoApiKey: '***', openaiApiKey: '***' });
                
                // Load API keys
                if (savedPreferences.locoApiKey) {
                    document.getElementById('locoApiKey').value = savedPreferences.locoApiKey;
                }
                if (savedPreferences.openaiApiKey) {
                    document.getElementById('openaiApiKey').value = savedPreferences.openaiApiKey;
                }
                
                // Load language selections
                if (savedPreferences.sourceLang) {
                    const sourceButton = document.querySelector(`#sourceLangGrid .lang-button[data-lang="${savedPreferences.sourceLang}"]`);
                    if (sourceButton) {
                        document.querySelectorAll('#sourceLangGrid .lang-button').forEach(btn => {
                            btn.dataset.selected = 'false';
                        });
                        sourceButton.dataset.selected = 'true';
                    }
                }
                
                if (savedPreferences.targetLang) {
                    const targetButton = document.querySelector(`#targetLangGrid .lang-button[data-lang="${savedPreferences.targetLang}"]`);
                    if (targetButton) {
                        document.querySelectorAll('#targetLangGrid .lang-button').forEach(btn => {
                            btn.dataset.selected = 'false';
                        });
                        targetButton.dataset.selected = 'true';
                    }
                }
                
                // Load other preferences
                document.getElementById('batchSize').value = savedPreferences.batchSize || 10;
                document.getElementById('ignoreBlank').checked = savedPreferences.ignoreBlank !== false;
                
                updateTableHeaders();
                document.getElementById('filterCheckbox').checked = savedPreferences.filterCheckbox || false;
            } catch (error) {
                console.error('Error loading preferences:', error);
            }
        }

        // Define all necessary functions
        const supportedLanguages = [
            'en-GB', 'de-DE', 'nl-NL', 'fr-FR', 'es-ES', 
            'it-IT', 'ro-RO', 'cs-CZ', 'bg-BG', 'el-GR', 
            'hu-HU', 'zh-CN', 'pl-PL'
        ];

        function getNextLanguage(currentLang) {
            const currentIndex = supportedLanguages.indexOf(currentLang);
            return supportedLanguages[(currentIndex + 1) % supportedLanguages.length];
        }

        function getPreviousLanguage(currentLang) {
            const currentIndex = supportedLanguages.indexOf(currentLang);
            return supportedLanguages[(currentIndex - 1 + supportedLanguages.length) % supportedLanguages.length];
        }

        function debugTranslationData(newLang) {
            console.log('=== Translation Debug Info ===');
            console.log('Target Language:', newLang);
            console.log('Window Translation Data:', window.translationData);
            console.log('Current Language Data:', window.translationData?.[newLang]);
            
            // Try to access a known key
            const testKey = 'Settings_Authentication_Title';
            console.log('Test key original translation:', window.translationData?.[newLang]?.[testKey]);
            
            // Log the full data structure
            console.log('Full data structure:', {
                windowTranslationData: window.translationData,
                currentLanguageData: window.translationData?.[newLang],
                currentDataState: currentData,
                flattenedTranslations: window.translationData?.[newLang] ? 
                    flattenObject(window.translationData[newLang]) : 'No data to flatten'
            });
        }

        function updateTargetLanguage(newLang) {
            console.log('Updating target language to:', newLang);
            
            // Simulate clicking "Start Translation" with the new language
            const startTranslationProcess = async () => {
                try {
                    const locoApiKey = document.getElementById('locoApiKey').value;
                    const filterCheckbox = document.getElementById('filterCheckbox').checked;
                    
                    if (!locoApiKey) {
                        showStatus('Please enter your Localise API key', 'error');
                        return;
                    }
                    
                    showStatus('Loading project data...', 'info');
                    
                    // Use existing window.translationData if available instead of fetching again
                    if (!window.translationData) {
                        let url = `/api/translations?key=${locoApiKey}`;
                        if (filterCheckbox) {
                            url += '&filter=!sameassource';
                        }
                        
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`API error: ${response.status} ${response.statusText}`);
                        }
                        
                        window.translationData = await response.json();
                    }
                    
                    // Update UI for new target language
                    document.querySelectorAll('#targetLangGrid .lang-button').forEach(btn => {
                        btn.dataset.selected = btn.dataset.lang === newLang ? 'true' : 'false';
                    });
                    
                    // Update language display text
                    const selectedButton = document.querySelector(`#targetLangGrid .lang-button[data-lang="${newLang}"]`);
                    if (selectedButton) {
                        const targetLangName = selectedButton.getAttribute('title');
                        document.getElementById('currentTargetLang').textContent = targetLangName;
                        
                        // Update table headers
                        document.getElementById('targetHeader1').textContent = `${targetLangName} (Original Translation)`;
                        document.getElementById('targetHeader2').textContent = `${targetLangName} (New Translation)`;
                    }
                    
                    // Get source and target data
                    const sourceLang = getSelectedLanguage('sourceLangGrid');
                    const sourceData = flattenObject(window.translationData[sourceLang] || {});
                    const targetData = flattenObject(window.translationData[newLang] || {});
                    
                    // Get checkbox states
                    const ignoreTranslated = document.getElementById('ignoreTranslated').checked;
                    const onlyEmpty = document.getElementById('onlyEmpty').checked;
                    
                    // Filter entries based on checkbox states
                    let entriesToTranslate = {};
                    let skippedCount = 0;
                    
                    Object.entries(sourceData).forEach(([key, sourceText]) => {
                        const existingTranslation = targetData[key];
                        const isEmpty = !existingTranslation || existingTranslation.trim() === '';
                        
                        let shouldTranslate = true;
                        
                        if (onlyEmpty) {
                            shouldTranslate = isEmpty;
                        } else if (ignoreTranslated) {
                            shouldTranslate = !existingTranslation;
                        }
                        
                        if (shouldTranslate) {
                            entriesToTranslate[key] = sourceText;
                        } else {
                            skippedCount++;
                        }
                    });
                    
                    // Reset currentData for new language
                    currentData = {
                        englishSource: sourceData,
                        targetLang: newLang,
                        translationQueue: Object.entries(entriesToTranslate),
                        totalEntries: Object.keys(entriesToTranslate).length,
                        processedKeys: new Set(),
                        translationResults: currentData.translationResults || {},
                        currentBatch: 0,
                        batchSize: parseInt(document.getElementById('batchSize').value)
                    };
                    
                    // Update UI
                    document.getElementById('totalEntries').textContent = currentData.totalEntries;
                    document.getElementById('translatedEntries').textContent = '0';
                    
                    // Reset progress bar
                    const progressFill = document.getElementById('progressFill');
                    const progressPercentage = document.getElementById('progressPercentage');
                    progressFill.style.width = '0%';
                    progressPercentage.textContent = '0%';
                    
                    // Update table content
                    const translationTable = document.getElementById('translationTable');
                    const rows = Array.from(translationTable.getElementsByTagName('tr'));
                    
                    rows.forEach(row => {
                        if (!row.id) return; // Skip header row
                        const key = row.id.replace('row-', '');
                        
                        // Update original translation column
                        const originalCell = row.cells[2];
                        if (originalCell) {
                            originalCell.textContent = targetData[key] || '';
                        }
                        
                        // Clear new translation column
                        const newTranslationCell = document.getElementById(`translation-${key}`);
                        if (newTranslationCell) {
                            newTranslationCell.textContent = '';
                        }
                        
                        // Update row styling
                        const hasTranslation = !!targetData[key];
                        const isEmpty = !hasTranslation;
                        
                        if ((hasTranslation && ignoreTranslated) || (!isEmpty && onlyEmpty)) {
                            row.style.backgroundColor = '#f5f5f5';
                            row.style.color = '#999';
                        } else {
                            row.style.backgroundColor = '';
                            row.style.color = '';
                        }
                    });
                    
                    // Update Next Batch button state
                    const nextBtn = document.getElementById('nextBtn');
                    nextBtn.disabled = currentData.totalEntries === 0;
                    
                    // Show status message
                    const skippedMessage = skippedCount > 0 ? 
                        ` (${skippedCount} entries skipped as already translated)` : '';
                    showStatus(`Loaded ${currentData.totalEntries} entries${skippedMessage}. Click "Next Batch" to start translation.`, 'success');
                    
                } catch (error) {
                    console.error('Error:', error);
                    showStatus('Error updating target language: ' + error.message, 'error');
                }
            };
            
            // Execute the process
            startTranslationProcess();
        }

        // Helper function to update progress bar
        function updateProgressBar(percentage) {
            const progressFill = document.getElementById('progressFill');
            const progressPercentage = document.getElementById('progressPercentage');
            if (progressFill && progressPercentage) {
                progressFill.style.width = `${percentage}%`;
                progressPercentage.textContent = `${Math.round(percentage)}%`;
            }
        }

        // Helper function to update statistics
        function updateStatistics(needsTranslation, total) {
            const statsDisplay = document.getElementById('statsDisplay');
            if (statsDisplay) {
                statsDisplay.textContent = `Entries to translate: ${needsTranslation} / Total entries: ${total}`;
            }
        }

        function setupNavigationButtons() {
            console.log('Setting up navigation buttons...');
            
            const prevBtn = document.getElementById('prevLang');
            const nextBtn = document.getElementById('nextLang');
            
            if (!prevBtn || !nextBtn) {
                console.error('Navigation buttons not found in DOM');
                return;
            }
            
            console.log('Found navigation buttons:', { prevBtn, nextBtn });

            prevBtn.onclick = () => {
                console.log('Previous button clicked');
                const currentLang = getSelectedLanguage('targetLangGrid');
                console.log('Current language:', currentLang);
                const prevLang = getPreviousLanguage(currentLang);
                console.log('Switching to previous language:', prevLang);
                updateTargetLanguage(prevLang);
            };
            
            nextBtn.onclick = () => {
                console.log('Next button clicked');
                const currentLang = getSelectedLanguage('targetLangGrid');
                console.log('Current language:', currentLang);
                const nextLang = getNextLanguage(currentLang);
                console.log('Switching to next language:', nextLang);
                updateTargetLanguage(nextLang);
            };
        }

        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize language buttons
            initLanguageButtons();
            
            // Load saved preferences
            loadSavedPreferences();
            
            // Setup navigation buttons
            setupNavigationButtons();
            
            // Update initial language display
            const initialLang = getSelectedLanguage('targetLangGrid');
            const initialLangButton = document.querySelector(`#targetLangGrid .lang-button[data-lang="${initialLang}"]`);
            if (initialLangButton) {
                document.getElementById('currentTargetLang').textContent = initialLangButton.getAttribute('title');
            }

            // Add start button handler
            const startBtn = document.getElementById('startBtn');
            startBtn.addEventListener('click', async () => {
                try {
                    // Always use the current value from the input field
                    const locoApiKey = document.getElementById('locoApiKey').value.trim();
                    const openaiApiKey = localStorage.getItem('openaiApiKey');
                    const targetLang = getSelectedLanguage('targetLangGrid');
                    const sourceLang = getSelectedLanguage('sourceLangGrid');
                    const batchSize = parseInt(document.getElementById('batchSize').value);
                    const ignoreBlank = document.getElementById('ignoreBlank').checked;
                    const ignoreTranslated = document.getElementById('ignoreTranslated').checked;
                    const onlyEmpty = document.getElementById('onlyEmpty').checked;
                    const filterCheckbox = document.getElementById('filterCheckbox').checked;

                    if (!locoApiKey || !openaiApiKey || !targetLang || !sourceLang) {
                        showStatus('Please fill in all required fields and select both languages', 'error');
                        return;
                    }

                    showStatus('Loading project data...', 'info');

                    // Load translations with filter if checkbox is checked
                    let url = `/api/translations?key=${locoApiKey}`;
                    if (filterCheckbox) {
                        url += '&filter=!sameassource';
                    }

                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`API error: ${response.status} ${response.statusText}`);
                    
                    const data = await response.json();
                    
                    // Prepare data
                    let sourceData = flattenObject(data[sourceLang] || {});
                    if (ignoreBlank) {
                        sourceData = Object.fromEntries(
                            Object.entries(sourceData).filter(([_, value]) => 
                                value && typeof value === 'string' && value.trim() !== ''
                            )
                        );
                    }

                    // Get original translations
                    const originalTranslations = flattenObject(data[targetLang] || {});

                    // Filter out already translated entries if needed
                    let entriesToTranslate = { ...sourceData };
                    let skippedCount = 0;

                    entriesToTranslate = Object.fromEntries(
                        Object.entries(sourceData).filter(([key, sourceText]) => {
                            const existingTranslation = originalTranslations[key];
                            
                            // Skip if entry has translation and we only want empty entries
                            if (onlyEmpty && existingTranslation && existingTranslation.trim() !== '') {
                                skippedCount++;
                                return false;
                            }
                            
                            // Skip if entry has translation in target language and ignoreTranslated is checked
                            if (ignoreTranslated && existingTranslation) {
                                const shouldTranslate = shouldTranslateEntry(sourceText, existingTranslation, targetLang);
                                if (!shouldTranslate) {
                                    skippedCount++;
                                    return false;
                                }
                            }
                            
                            return true;
                        })
                    );

                    // Initialize OpenAI client
                    openaiClient = new OpenAI({
                        apiKey: openaiApiKey,
                        dangerouslyAllowBrowser: true
                    });

                    // Set up current data
                    currentData = {
                        englishSource: entriesToTranslate,
                        originalTranslations: originalTranslations,
                        translations: {},
                        totalEntries: Object.keys(entriesToTranslate).length,
                        currentBatch: 0,
                        batchSize: batchSize,
                        targetLang: targetLang,
                        sourceLang: sourceLang,
                        processedKeys: new Set(),
                        multiLanguageTranslations: {},
                        processedLanguages: new Set(),
                        currentBatchProgress: 0,
                        translationQueue: [], // Store entries that need translation
                        translationResults: {} // Store completed translations for all languages
                    };

                    // Clear and set up table
                    const translationTable = document.getElementById('translationTable');
                    translationTable.innerHTML = '';
                    
                    // Add headers
                    updateTableHeaders();
                    
                    // Sort entries: entries to translate first (white), then skipped entries (gray)
                    const allEntries = Object.entries(sourceData);
                    const sortedEntries = allEntries.sort((a, b) => {
                        const aNeeds = entriesToTranslate.hasOwnProperty(a[0]) ? 0 : 1;
                        const bNeeds = entriesToTranslate.hasOwnProperty(b[0]) ? 0 : 1;
                        return aNeeds - bNeeds;
                    });

                    // Show all source entries and their translations (if they exist)
                    sortedEntries.forEach(([key, sourceText]) => {
                        const row = translationTable.insertRow();
                        row.id = `row-${key}`;
                        
                        // Key column
                        const keyCell = row.insertCell();
                        keyCell.textContent = key;
                        
                        // Source text column
                        const sourceCell = row.insertCell();
                        sourceCell.textContent = sourceText;
                        
                        // Original translation column
                        const originalCell = row.insertCell();
                        originalCell.textContent = originalTranslations[key] || '';
                        
                        // New translation column (empty for now)
                        const newCell = row.insertCell();
                        newCell.id = `translation-${key}`;
                        newCell.textContent = '';
                        
                        // If this entry is not in entriesToTranslate, gray out the row
                        if (!entriesToTranslate[key]) {
                            row.style.backgroundColor = '#f5f5f5';
                            row.style.color = '#999';
                        }
                    });

                    // Update UI state
                    startBtn.disabled = true;
                    const nextBtn = document.getElementById('nextBtn');
                    const saveBtn = document.getElementById('saveBtn');
                    nextBtn.disabled = currentData.totalEntries === 0;
                    saveBtn.disabled = false;

                    // Update statistics
                    updateStatistics();

                    const skippedMessage = skippedCount > 0 ? 
                        ` (${skippedCount} entries skipped as already translated)` : '';
                    showStatus(`Loaded ${currentData.totalEntries} entries${skippedMessage}. Click "Next Batch" to start translation.`, 'success');

                } catch (error) {
                    console.error('Error:', error);
                    showStatus('Error: ' + error.message, 'error');
                    startBtn.disabled = false;
                }
            });

            // Add change handlers for API key inputs
            document.getElementById('locoApiKey').addEventListener('change', savePreferences);
            document.getElementById('openaiApiKey').addEventListener('change', savePreferences);
            document.getElementById('batchSize').addEventListener('change', savePreferences);
            document.getElementById('ignoreBlank').addEventListener('change', savePreferences);

            // Add Next button handler
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.addEventListener('click', () => {
                processBatch();
            });

            // Single save button handler
            const saveBtn = document.getElementById('saveBtn');
            saveBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                
                // Prevent multiple clicks
                if (saveBtn.dataset.saving === 'true') return;
                saveBtn.dataset.saving = 'true';
                
                try {
                    showStatus('Preparing translations for download...', 'info');
                    
                    // Create export data with all languages
                    const exportData = {};
                    
                    // Get all translated languages from translationResults
                    Object.entries(currentData.translationResults).forEach(([lang, translations]) => {
                        // Only include languages that have translations
                        if (Object.keys(translations).length > 0) {
                            exportData[lang] = unflattenObject(translations);
                        }
                    });

                    console.log('Final export data:', exportData);

                    // Create a Blob with the JSON data
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    
                    // Create a download link
                    const downloadLink = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    downloadLink.href = url;
                    downloadLink.download = `translations_all_languages_${new Date().toISOString().split('T')[0]}.json`;
                    
                    // Trigger the download
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    
                    // Cleanup
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                        document.body.removeChild(downloadLink);
                        saveBtn.dataset.saving = 'false';
                    }, 1000);
                    
                    showStatus('All translations downloaded successfully!', 'success');

                } catch (error) {
                    console.error('Error preparing download:', error);
                    showStatus('Error preparing download: ' + error.message, 'error');
                    saveBtn.dataset.saving = 'false';
                }
            });

            const modal = document.getElementById('apiModal');
            const configureBtn = document.getElementById('configureBtn');
            const closeBtn = document.querySelector('.close-modal');
            const saveApiKeysBtn = document.getElementById('saveApiKeys');

            // Add this function to handle API key display
            function formatApiKeyDisplay(apiKey) {
                if (!apiKey) return '';
                if (apiKey.length < 7) return apiKey; // If key is too short, show as is
                return `${apiKey.slice(0, 3)}...${apiKey.slice(-4)}`;
            }

            // Update the modal open handler to show masked key
            configureBtn.addEventListener('click', () => {
                modal.style.display = 'block';
                // Load saved OpenAI key if exists
                const openaiKey = localStorage.getItem('openaiApiKey');
                const openaiInput = document.getElementById('openaiApiKey');
                
                if (openaiKey) {
                    openaiInput.value = openaiKey;
                    openaiInput.setAttribute('data-full-key', openaiKey);
                    openaiInput.value = formatApiKeyDisplay(openaiKey);
                }
            });

            // Add input handler to manage key display/edit
            document.getElementById('openaiApiKey').addEventListener('focus', function() {
                const fullKey = this.getAttribute('data-full-key');
                if (fullKey) {
                    this.value = fullKey;
                }
            });

            document.getElementById('openaiApiKey').addEventListener('blur', function() {
                if (this.value.length > 0) {
                    this.setAttribute('data-full-key', this.value);
                    this.value = formatApiKeyDisplay(this.value);
                }
            });

            // Update save handler to use full key
            saveApiKeysBtn.addEventListener('click', () => {
                const openaiInput = document.getElementById('openaiApiKey');
                const openaiKey = openaiInput.getAttribute('data-full-key') || openaiInput.value;
                
                localStorage.setItem('openaiApiKey', openaiKey);
                modal.style.display = 'none';
                
                // Reinitialize OpenAI client with new key
                openaiClient = new OpenAI({
                    apiKey: openaiKey,
                    dangerouslyAllowBrowser: true
                });
                
                showStatus('OpenAI API key saved successfully', 'success');
            });

            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });

            window.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });

            const loadProjectBtn = document.getElementById('loadProjectBtn');
            loadProjectBtn.addEventListener('click', async () => {
                try {
                    const locoApiKey = document.getElementById('locoApiKey').value;
                    const filterCheckbox = document.getElementById('filterCheckbox').checked;

                    if (!locoApiKey) {
                        showStatus('Please enter your Localise API key', 'error');
                        return;
                    }

                    // Show loading status
                    showStatus('Loading project data...', 'info');

                    // Simple URL construction without any encoding
                    let url = `/api/translations?key=${locoApiKey}`;
                    if (filterCheckbox) {
                        url += '&filter=!sameassource';
                    }

                    console.log('DEBUG - Client request URL:', url);

                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log('DEBUG - Received data keys:', Object.keys(data).slice(0, 5));
                    // ... rest of the code

                    // Update statistics
                    const totalEntries = Object.keys(data['en-GB'] || {}).length;
                    document.getElementById('totalEntries').textContent = totalEntries;
                    document.getElementById('translatedEntries').textContent = '0';
                    document.getElementById('progressPercentage').textContent = '0%';
                    document.getElementById('progressFill').style.width = '0%';

                    // Store the data for later use
                    window.translationData = data;

                    showStatus('Project loaded successfully!', 'success');

                } catch (error) {
                    console.error('Error:', error);
                    showStatus('Error loading project: ' + error.message, 'error');
                }
            });

            // Add these functions before setupNavigationButtons
            const supportedLanguages = [
                'en-GB', 'de-DE', 'nl-NL', 'fr-FR', 'es-ES', 
                'it-IT', 'ro-RO', 'cs-CZ', 'bg-BG', 'el-GR', 
                'hu-HU', 'zh-CN', 'pl-PL'
            ];

            function getNextLanguage(currentLang) {
                const currentIndex = supportedLanguages.indexOf(currentLang);
                return supportedLanguages[(currentIndex + 1) % supportedLanguages.length];
            }

            function getPreviousLanguage(currentLang) {
                const currentIndex = supportedLanguages.indexOf(currentLang);
                return supportedLanguages[(currentIndex - 1 + supportedLanguages.length) % supportedLanguages.length];
            }

            function updateTargetLanguage(newLang) {
                // Update the target language selection in the grid
                document.querySelectorAll('#targetLangGrid .lang-button').forEach(btn => {
                    btn.dataset.selected = btn.dataset.lang === newLang ? 'true' : 'false';
                });
                
                // Update currentData target language
                currentData.targetLang = newLang;
                
                // Get original translations from Localise API
                const originalTranslations = window.translationData && window.translationData[newLang] ? 
                    flattenObject(window.translationData[newLang]) : {};
                console.log('Flattened original translations:', originalTranslations);
                
                // Get our new translations
                const newTranslations = currentData.translationResults?.[newLang] || {};
                console.log('New translations for this language:', newTranslations);
                
                // Get checkbox states
                const ignoreTranslated = document.getElementById('ignoreTranslated').checked;
                const onlyEmpty = document.getElementById('onlyEmpty').checked;
                
                // Show translations for the new language
                const translationTable = document.getElementById('translationTable');
                const rows = translationTable.getElementsByTagName('tr');
                
                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    if (!row.id) continue; // Skip header row
                    
                    const key = row.id.replace('row-', '');
                    
                    // Update original translation column from Localise API
                    const cells = row.getElementsByTagName('td');
                    if (cells.length >= 3) {
                        const originalCell = cells[2];
                        const originalTranslation = originalTranslations[key] || '';
                        console.log(`Setting original translation for ${key}:`, originalTranslation);
                        originalCell.textContent = originalTranslation;
                    }
                    
                    // Update new translation column from our translations
                    const translationCell = document.getElementById(`translation-${key}`);
                    if (translationCell) {
                        const newTranslation = newTranslations[key] || '';
                        console.log(`Setting new translation for ${key}:`, newTranslation);
                        translationCell.textContent = newTranslation;
                        
                        // Determine if this row should be grayed out based on checkbox states
                        const hasOriginalTranslation = !!originalTranslations[key];
                        const isEmpty = !originalTranslations[key] && !newTranslation;
                        
                        if (hasOriginalTranslation && ignoreTranslated) {
                            // Gray out if we're ignoring already translated entries
                            row.style.backgroundColor = '#f5f5f5';
                            row.style.color = '#999';
                        } else if (!isEmpty && onlyEmpty) {
                            // Gray out if we're only translating empty entries and this one isn't empty
                            row.style.backgroundColor = '#f5f5f5';
                            row.style.color = '#999';
                        } else {
                            // Reset styling for entries that need translation
                            row.style.backgroundColor = '';
                            row.style.color = '';
                        }
                    }
                }
                
                // Update currentData with new counts
                currentData.totalEntries = Object.keys(newTranslations).length;
                
                // Enable/disable Next Batch button based on remaining translations
                const nextBtn = document.getElementById('nextBtn');
                if (nextBtn) {
                    nextBtn.disabled = Object.keys(newTranslations).length === 0;
                }
                
                // Update statistics display
                const statsDisplay = document.getElementById('statsDisplay');
                if (statsDisplay) {
                    statsDisplay.textContent = `Entries to translate: ${Object.keys(newTranslations).length} / Total entries: ${Object.keys(newTranslations).length}`;
                }
                
                // Save preferences
                savePreferences();
            }

            // Add event listeners in your DOMContentLoaded handler
            document.addEventListener('DOMContentLoaded', () => {
                // Initialize language buttons
                initLanguageButtons();
                
                // Load saved preferences
                loadSavedPreferences();

                // Add navigation button handlers with console logs
                const prevBtn = document.getElementById('prevLang');
                const nextBtn = document.getElementById('nextLang');
                
                console.log('Navigation buttons:', { prevBtn, nextBtn });

                prevBtn.addEventListener('click', () => {
                    console.log('Previous button clicked');
                    const currentLang = getSelectedLanguage('targetLangGrid');
                    console.log('Current language:', currentLang);
                    const prevLang = getPreviousLanguage(currentLang);
                    console.log('Switching to previous language:', prevLang);
                    updateTargetLanguage(prevLang);
                });
                
                nextBtn.addEventListener('click', () => {
                    console.log('Next button clicked');
                    const currentLang = getSelectedLanguage('targetLangGrid');
                    console.log('Current language:', currentLang);
                    const nextLang = getNextLanguage(currentLang);
                    console.log('Switching to next language:', nextLang);
                    updateTargetLanguage(nextLang);
                });
                
                // Update initial language display
                const initialLang = getSelectedLanguage('targetLangGrid');
                const initialLangButton = document.querySelector(`#targetLangGrid .lang-button[data-lang="${initialLang}"]`);
                if (initialLangButton) {
                    document.getElementById('currentTargetLang').textContent = initialLangButton.getAttribute('title');
                }
            });
        });

        function initLanguageButtons() {
            // Source language buttons
            document.querySelectorAll('#sourceLangGrid .lang-button').forEach(button => {
                button.addEventListener('click', () => {
                    // Update visual state
                    document.querySelectorAll('#sourceLangGrid .lang-button').forEach(btn => {
                        btn.dataset.selected = 'false';
                    });
                    button.dataset.selected = 'true';
                    
                    // Update data and UI
                    currentData.sourceLang = button.dataset.lang;
                    updateTableHeaders();
                    savePreferences();
                });
            });

            // Target language buttons
            document.querySelectorAll('#targetLangGrid .lang-button').forEach(button => {
                button.addEventListener('click', () => {
                    // Use our existing updateTargetLanguage function
                    updateTargetLanguage(button.dataset.lang);
                });
            });
        }

        // Add status display function
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            if (!statusDiv) {
                console.error('Status element not found');
                return;
            }
            
            statusDiv.textContent = message;
            statusDiv.className = 'status-message ' + type;
            
            // Optionally auto-hide success messages after 3 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

        // Add translateText function
        function getGlossaryPrompt(text, targetLang) {
            console.log('Checking glossary for:', text);
            console.log('Target language:', targetLang);
            console.log('Available glossary:', window.glossary);

            const normalizedText = text.toLowerCase();
            console.log('Normalized text:', normalizedText);
            console.log('Glossary entry found:', window.glossary[normalizedText]);
            console.log('Glossary translation for target language:', window.glossary[normalizedText]?.[targetLang]);

            // Convert language codes
            const langMapping = {
                'en-GB': 'en-GB',
                'fr-FR': 'fr-FR',
                'de-DE': 'de-DE',
                'nl-NL': 'nl-NL',
                'it-IT': 'it-IT',
                'hu-HU': 'hu-HU',
                'cs-CZ': 'cs-CZ',
                'ro-RO': 'ro-RO',
                'bg-BG': 'bg-BG',
                'es-ES': 'es-ES',
                'zh-CN': 'zh-CN',
                'pl-PL': 'pl-PL'
            };

            const langCode = langMapping[targetLang];
            console.log('Mapped language code:', langCode);
            
            if (!langCode || !window.glossary) {
                console.log('Missing langCode or glossary:', { langCode, hasGlossary: !!window.glossary });
                return '';
            }

            // Find matching glossary terms
            const matches = Object.entries(window.glossary).filter(([key]) => {
                const term = key.toLowerCase();
                const textLower = text.toLowerCase();
                const isMatch = textLower.includes(term) || 
                               textLower.includes(term + 's') || 
                               textLower.includes(term + "'s") || 
                               (term === 'you' && textLower.includes('your'));
                console.log(`Checking term "${term}" against "${textLower}":`, isMatch);
                return isMatch;
            });

            console.log('Found matches:', matches);

            if (matches.length === 0) return '';

            // Build prompt addition
            const translations = matches.map(([key, translations]) => {
                const translation = translations[langCode];
                // Check if translation is empty or undefined
                if (!translation) {
                    console.log(`Ignoring empty or undefined translation for ${key}`);
                    return null; // Return null to filter out
                }
                console.log(`Getting translation for ${key}:`, translation);
                return `"${key}": "${translation}"`;
            }).filter(Boolean); // Filter out null values

            // Only include the glossary prompt if there are valid translations
            const prompt = translations.length > 0 
                ? `Please keep in mind the following glossary: ${translations.join(', ')}. ` 
                : ''; // Empty prompt if no valid translations

            console.log('Final glossary prompt:', prompt);
            return prompt;
        }

        async function translateText(text, targetLang, key) {
            try {
                // Get glossary prompt
                const glossaryPrompt = getGlossaryPrompt(text, targetLang);
                
                const completion = await openaiClient.chat.completions.create({
                    messages: [
                        {
                            role: "system",
                            content: `You are a professional translator for a B2B foreign exchange and cross-border payments platform. Translate to ${targetLang}.
                            
                            These translations are being imported from a translation management platform (Localise.biz) where each asset has a unique ID.
                            The asset ID provides context about the UI element type (Button/CTA, Title, Label, Error, etc).
                            
                            Important rules:
                            1. ${glossaryPrompt}
                            2. Adapt the case, gender, number, and declination of any glossary terms for grammatical correctness
                            3. Preserve ALL variables without translation: %variable%, %%variable%%, {{variable}}
                            4. ONLY include HTML tags that exist in the original text - DO NOT add new ones
                            5. Keep existing HTML tags (<br>, <p>, etc.) exactly as they appear
                            6. You must keep at all costs the "/n" and "/t" as they are in the original text like the following example "add a beneficiary in the platform. \n \n If you did not initiate this action"
                            7. DO NOT translate: HTML tags, URLs, date formats like DD/MM/YYYY HH:mm or similar
                            8. Use terminology and phrasing that is the most commonly used by fintechs and banks in ${targetLang}, prioritizing clarity and naturalness for business clients. When multiple correct translations exist, prefer the one most frequently used in the financial and FX industry.  
                            9. Prefer terminology commonly used by leading fintech and FX providers such as **Wise, Revolut, and iBanFirst** to ensure industry consistency.  
                            
                            Context: The platform handles currency conversion, international payments, and financial operations for business clients.`
                        },
                        {
                            role: "user",
                            content: `Asset ID: ${key}
                            Text to translate: ${text}`
                        }
                    ],
                    model: "chatgpt-4o-latest",
                    temperature: 1,
                });

                let translatedText = completion.choices[0].message.content.trim();
                
                // Remove "The text to translate is:" if it appears in the response
                translatedText = translatedText.replace(/^The text to translate is:\s*/i, '');
                
                return translatedText;
            } catch (error) {
                console.error('Translation error:', error);
                throw new Error(`Translation failed: ${error.message}`);
            }
        }

        // Add this to your global variables
        const SUPPORTED_LANGUAGES = {
            'en-GB': 'eng',  // English
            'de-DE': 'deu',  // German
            'nl-NL': 'nld',  // Dutch
            'fr-FR': 'fra',  // French
            'es-ES': 'spa',  // Spanish
            'it-IT': 'ita',  // Italian
            'ro-RO': 'ron',  // Romanian
            'cs-CZ': 'ces',  // Czech
            'bg-BG': 'bul',  // Bulgarian
            'el-GR': 'ell',  // Greek
            'hu-HU': 'hun',  // Hungarian
            'zh-CN': 'cmn',   // Chinese
            'pl-PL': 'pol'   // Polish
        };

        // Add language detection function
        function detectLanguage(text) {
            // Wait for franc to be available
            if (typeof window.franc === 'undefined') {
                console.error('Franc not loaded yet');
                return null;
            }
            
            if (!text || text.trim().length < 10) {
                console.log('Text too short for detection:', text);
                return null;
            }
            
            try {
                const detectedLang = window.franc(text, {
                    only: Object.values(SUPPORTED_LANGUAGES),
                    minLength: 1
                });
                
                // Simpler debug output without franc.all
                console.log('Language Detection Debug:', {
                    text: text,
                    detectedCode: detectedLang,
                    textLength: text.length,
                    supportedLanguages: Object.values(SUPPORTED_LANGUAGES)
                });
                
                const detectedLocale = Object.keys(SUPPORTED_LANGUAGES).find(
                    locale => SUPPORTED_LANGUAGES[locale] === detectedLang
                );
                
                console.log('Detected locale:', detectedLocale);
                return detectedLocale;
            } catch (error) {
                console.error('Language detection error:', error);
                return null;
            }
        }

        // Update the translation process to skip already translated entries
        function shouldTranslateEntry(sourceText, existingTranslation, targetLang) {
            // If no existing translation, always translate
            if (!existingTranslation) return true;
            
            // Detect language of existing translation
            const detectedLang = detectLanguage(existingTranslation);
            
            // If we can't detect the language (too short/ambiguous) or 
            // if detected language doesn't match target language, translate it
            if (!detectedLang || detectedLang !== targetLang) return true;
            
            // If ignore translated is checked and text is in target language, skip it
            return !document.getElementById('ignoreTranslated').checked;
        }

        // Update processBatch function
        async function processBatch() {
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.classList.add('loading');
            nextBtn.textContent = 'Translating...';
            
            try {
                const translateAll = document.getElementById('translateAll').checked;
                
                // Initialize translation queue if empty
                if (currentData.translationQueue.length === 0) {
                    currentData.translationQueue = Object.entries(currentData.englishSource)
                        .filter(([key]) => !currentData.processedKeys.has(key));
                }
                
                // Get next batch of entries
                const entries = currentData.translationQueue.slice(0, currentData.batchSize);

                if (translateAll) {
                    // Initialize storage for all languages
                    if (!currentData.translationResults) {
                        currentData.translationResults = {};
                    }

                    // Get all target languages except source
                    const targetLanguages = supportedLanguages.filter(lang => 
                        lang !== currentData.sourceLang && 
                        document.querySelector(`#targetLangGrid .lang-button[data-lang="${lang}"]`)
                    );

                    // Initialize storage for each language
                    targetLanguages.forEach(lang => {
                        if (!currentData.translationResults[lang]) {
                            currentData.translationResults[lang] = {};
                        }
                    });

                    // Process each entry for all languages
                    for (const [key, sourceText] of entries) {
                        showStatus(`Translating entry ${currentData.processedKeys.size + 1}/${currentData.totalEntries} to all languages...`, 'info');
                        
                        for (const targetLang of targetLanguages) {
                            try {
                                const translation = await translateText(sourceText, targetLang, key);
                                
                                // Store in results
                                currentData.translationResults[targetLang][key] = translation;
                                
                                // Update UI if this is the current target language
                                if (targetLang === currentData.targetLang) {
                                    const cell = document.getElementById(`translation-${key}`);
                                    if (cell) cell.textContent = translation;
                                }
                                
                                // Update progress
                                currentData.processedLanguages.add(targetLang);
                                
                            } catch (error) {
                                console.error(`Error translating to ${targetLang}:`, error);
                                showStatus(`Error translating to ${targetLang}: ${error.message}`, 'error');
                            }
                        }
                        
                        currentData.processedKeys.add(key);
                        // Remove processed entry from queue
                        currentData.translationQueue = currentData.translationQueue.filter(([k]) => k !== key);
                        updateStatistics();
                    }
                } else {
                    // Single language translation
                    if (!currentData.translationResults[currentData.targetLang]) {
                        currentData.translationResults[currentData.targetLang] = {};
                    }

                    for (const [key, sourceText] of entries) {
                        showStatus(`Translating entry ${currentData.processedKeys.size + 1}/${currentData.totalEntries}...`, 'info');
                        const translation = await translateText(sourceText, currentData.targetLang, key);
                        
                        // Store translation
                        currentData.translationResults[currentData.targetLang][key] = translation;
                        
                        // Update UI
                        const cell = document.getElementById(`translation-${key}`);
                        if (cell) cell.textContent = translation;
                        
                        currentData.processedKeys.add(key);
                        // Remove processed entry from queue
                        currentData.translationQueue = currentData.translationQueue.filter(([k]) => k !== key);
                        updateStatistics();
                    }
                }

                // Update UI state
                const saveBtn = document.getElementById('saveBtn');
                saveBtn.disabled = false;
                nextBtn.disabled = currentData.translationQueue.length === 0;
                
                if (currentData.translationQueue.length === 0) {
                    showStatus('All translations completed!', 'success');
                }

                // Update progress bar
                const progress = ((currentData.totalEntries - currentData.translationQueue.length) / currentData.totalEntries) * 100;
                document.getElementById('progressFill').style.width = `${progress}%`;
                document.getElementById('progressPercentage').textContent = `${Math.round(progress)}%`;

            } catch (error) {
                console.error('Batch processing error:', error);
                showStatus('Error processing batch: ' + error.message, 'error');
            } finally {
                nextBtn.classList.remove('loading');
                nextBtn.textContent = 'Next Batch';
            }
        }

        // Add statistics update function
        function updateStatistics() {
            const totalEntries = Object.keys(currentData.englishSource || {}).length;
            const translatedEntries = currentData.processedKeys.size;
            const progressPercentage = totalEntries ? Math.round((translatedEntries / totalEntries) * 100) : 0;

            document.getElementById('totalEntries').textContent = totalEntries;
            document.getElementById('translatedEntries').textContent = translatedEntries;
            document.getElementById('progressPercentage').textContent = `${progressPercentage}%`;
            document.getElementById('progressFill').style.width = `${progressPercentage}%`;
        }

        // Add helper function to flatten nested objects
        function flattenObject(obj, prefix = '') {
            return Object.keys(obj).reduce((acc, key) => {
                const pre = prefix.length ? prefix + '.' : '';
                if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
                    Object.assign(acc, flattenObject(obj[key], pre + key));
                } else {
                    acc[pre + key] = obj[key];
                }
                return acc;
            }, {});
        }

        // Add helper function to unflatten object for export
        function unflattenObject(obj) {
            const result = {};
            
            for (const key in obj) {
                const keys = key.split('.');
                let current = result;
                
                for (let i = 0; i < keys.length - 1; i++) {
                    current[keys[i]] = current[keys[i]] || {};
                    current = current[keys[i]];
                }
                
                current[keys[keys.length - 1]] = obj[key];
            }
            
            return result;
        }


                // Project management
        const projectModal = document.getElementById('projectModal');
        const projectForm = document.getElementById('projectForm');
        const projectSelect = document.getElementById('projectSelect');
        const addProjectBtn = document.getElementById('addProjectBtn');

        // Load projects on page load
        async function loadProjects() {
            try {
                const response = await fetch('/api/projects');
                const projects = await response.json();
                
                // Clear existing options except the placeholder
                projectSelect.innerHTML = '<option value="">Select a project...</option>';
                
                // Add projects to select
                projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project.readOnlyKey;
                    option.textContent = project.name;
                    projectSelect.appendChild(option);
                });

                // Select last used project if any
                const lastProject = localStorage.getItem('lastProject');
                if (lastProject) {
                    projectSelect.value = lastProject;
                    if (projectSelect.value) { // If project exists
                        loadProject(projectSelect.value);
                    }
                }
            } catch (error) {
                showStatus('Error loading projects: ' + error.message, 'error');
            }
        }

        // Show modal to add new project
        addProjectBtn.addEventListener('click', () => {
            projectModal.classList.add('show');
            projectForm.reset();
        });

        // Add this to your existing JavaScript section
        const closeProjectModalBtn = projectModal.querySelector('.close-modal');

        // Close modal when clicking the X button
        closeProjectModalBtn.addEventListener('click', () => {
            projectModal.classList.remove('show');
        });

        // Optional: Close modal when clicking outside
        projectModal.addEventListener('click', (e) => {
            if (e.target === projectModal) {
                projectModal.classList.remove('show');
            }
        });

        // Handle project form submission
        projectForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const projectData = {
                name: document.getElementById('projectName').value,
                readOnlyKey: document.getElementById('readOnlyKey').value,
                writeKey: document.getElementById('writeKey').value
            };

            try {
                const response = await fetch('/api/projects', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(projectData)
                });

                const result = await response.json();
                
                if (result.error) {
                    throw new Error(result.error);
                }

                // Reload projects and close modal
                await loadProjects();
                projectModal.classList.remove('show');
                projectForm.reset();
                
                // Select the new project
                projectSelect.value = projectData.readOnlyKey;
                loadProject(projectData.readOnlyKey);
                
                showStatus('Project added successfully', 'success');
            } catch (error) {
                showStatus('Error adding project: ' + error.message, 'error');
            }
        });

        // Handle project selection
        projectSelect.addEventListener('change', (e) => {
            const apiKey = e.target.value;
            if (apiKey) {
                localStorage.setItem('lastProject', apiKey);
                loadProject(apiKey);
            }
        });

        // Load projects on page load
        document.addEventListener('DOMContentLoaded', loadProjects);

    </script> 
</body>
</html> 